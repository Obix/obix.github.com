<html><!-- #BeginTemplate "/Templates/pragmatics.dwt" --><!-- DW6 -->
<head>
<!-- #BeginEditable "doctitle" --> 
<title>Software quality (Obix programming language pragmatic)</title>
<!-- #EndEditable -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../../styles.css" type="text/css">
</head>

<body>
<table border="0" width="100%"><tr>
    <td> <!-- #BeginEditable "previous_page" --><a href="introduction.html">Previous 
      page</a><!-- #EndEditable --> 
      | <!-- #BeginEditable "next_page" --><a href="pragmatics-error_handling.html">Next 
      page</a><!-- #EndEditable --> 
      | <a href="contents.html">Contents</a> | <a href="../../index.html">Home</a> 
    </td>
    <td align=right>Obix pragmatics</td>
</tr></table>
<hr>
<!-- #BeginEditable "text" --> 
<h1>Quality</h1>
<p class="pragmatic">Quality is a permanent and implicit requirement!</p>
<p>Yes, this pragmatic seems quite too obvious to be worth talking about. We all 
  <i>know</i> that everyone wants high quality. So, why mention it in first place? 
  The reason is that creating high quality software is not easy at all. Plenty 
  of source code (including most software I have written), is not of high quality. 
  Two main reasons are:</p>
<ul>
  <li>writing high quality software requires a lot of knowledge, experience and 
    discipline, especially if there is no or little support integrated in the 
    used programming language and tools<br>
    <br>
  </li>
  <li>writing high quality software <i>seems</i> to reduce productivity, because 
    the benefits only become visible much later</li>
</ul>
<p>Let's take a very typical example. We have to add a new functionality to an 
  existing program. After examining the source code, which may have been written 
  by someone else, we see that it is of bad quality and/or it is not prepared 
  to add the new functionality in an appropriate way. Or, worse, it contains programming 
  errors. In this case we have two possibilities:</p>
<ol>
  <li>first we refactor the existing code (this takes time), and then we add the 
    new functionality in a well designed, properly implemented way.<br>
    <br>
  </li>
  <li>we accept the existing code (after all, it works and our client is impatient), 
    and quickly change the code in a mediocre way.</li>
</ol>
<p>It is a fact that programmers frequently choose solution 2, because they may 
  feel themselves not responsible for the bad code, because it is often a frustrating 
  task to change existing code, and also because it may take a lot of time (days, 
  weeks or even months). But, as software often has to be changed in the real 
  world (about 70% of a programmer's time is spent on maintenance), the consequence 
  of repeatedly doing changes in such a way will undoubtedly end up in a disaster: 
  unstable, unmaintainable spaghetti code.</p>
<p>Hence, we constantly have to resist against writing low quality, unmaintainable 
  code.</p>
<p> Moreover, we should always keep in mind that:</p>
<p align="center"> <b>high quality code always<i> reduces</i> total software development 
  costs</b></p>
<p>even if at some points much more time must be invested.</p>
<p>But: What exactly is high quality code? Typically, when speaking about quality 
  of software, we think of the following properties:</p>
<ul>
  <li><b>correctness (accuracy)</b><br>
    the ability of the software to execute the tasks exactly as defined in the 
    specifications, without any faults<br>
    <br>
    examples: 
    <ul>
      <li>the total amount of an invoice is the exact sum of the items' quantities 
        multiplied by their unit price.</li>
      <li>the quantity in stock displayed on screen is correct; we can absolutely 
        rely on the data.</li>
      <li>the balance sheet is always balanced (sum of all debits = the sum of 
        all credits)<br>
        <b><br>
        </b></li>
    </ul>
  </li>
  <li><b>reliability (robustness, stability, integrity)<br>
    </b>the ability to perform the tasks under normal conditions and to react 
    appropriately under any abnormal conditions.<br>
    <br>
    examples: 
    <ul>
      <li>any data entry is checked for validity and refused in the case of error.</li>
      <li>the system doesn't crash and loose data, but reacts appropriately in 
        the case of an unavailable resource (e.g. a file open error)</li>
      <li>data integrity is guaranteed in the case of power failure.<br>
        <br>
      </li>
    </ul>
  </li>
  <li><b>ease-of-use<br>
    </b>the ability of the users (end-users, administrators and developers) to 
    quickly learn, understand and use the software<br>
    <br>
  </li>
  <li><b>flexibility (adaptability, extendibility, compatibility, portability)<br>
    </b>the ability of the software to be adapted easily to new or modified specifications 
    and requirements of the users<br>
    <br>
  </li>
  <li><b>reusability<br>
    </b>the ability of a piece of software to be reused in the same or another 
    domain (application) and/or to be extended for new functionalities, without 
    having to re-implement its existing functionalities.<br>
    <br>
  </li>
  <li><b>efficiency (speed)<br>
    </b>the absence of any waiting times for users as well as the ability to use 
    as few resources as possible.<br>
    <br>
  </li>
  <li><b>maintainability (readability, testability)<br>
    </b>the easiness for administrators and developers to detect and correct errors 
    and to quickly understand and adapt the software to changes in requirements.<br>
    <br>
  </li>
  <li><b>security<br>
    </b>the ability of the software to protect data against unauthorized access 
    as well as the possibility to trace actions to any desired precision.</li>
</ul>
<p>Obviously, there are a lot of requirements to be fulfilled by high quality 
  software. Each of the following pragmatics concerns quality and contributes 
  to one or more of the above properties.</p>
<!-- #EndEditable --> 
<hr>
<table border="0" width="100%"><tr>
    <td> <!-- #BeginEditable "previous_page-bottom" --><a href="introduction.html">Previous 
      page</a><!-- #EndEditable --> 
      | <!-- #BeginEditable "next_page-bottom" --><a href="pragmatics-error_handling.html">Next 
      page</a><!-- #EndEditable --> 
      | <a href="contents.html">Contents</a> | <a href="../../index.html">Home</a> 
    </td>
    <td align=right>October 2004</td>
</tr></table>
</body>
<!-- #EndTemplate --></html>
