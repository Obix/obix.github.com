<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Obix's 24 Fail fast! concepts for more reliable software</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="obix_articles.html" title="Obix articles"><link rel="prev" href="why_obix.html" title="Why Obix? Reliable code and software developer productivity"><link rel="next" href="introduction_to_obix.html" title="The Obix programming language: more reliable code in less time"><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29648172-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Obix's 24 <span class="emphasis"><em>Fail fast!</em></span> concepts for more reliable software</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="why_obix.html">Prev</a> </td><th width="60%" align="center">Obix articles</th><td width="20%" align="right"> <a accesskey="n" href="introduction_to_obix.html">Next</a></td></tr></table><hr></div><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="reliability_features"></a>Obix's 24 <span class="emphasis"><em>Fail fast!</em></span> concepts for more reliable software</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Christian</span> <span class="surname">Neumanns</span></h3></div></div><div><p class="pubdate">March 2011</p></div></div><hr></div><p>The number 1 goal of Obix is to help writing more reliable code in less time.</p><p>To achieve this goal, Obix incorporates 24 <span class="emphasis"><em>Fail fast!</em></span> concepts which are briefly described in this article. You will see <span class="emphasis"><em>why</em></span> these <span class="emphasis"><em>Fail fast!</em></span> concepts contribute to more reliability and examples illustrate <span class="emphasis"><em>how</em></span> it works. You will also find many links for more information in Obix's programming language manual.</p><p>Designed to work seamlessly together, Obix's <span class="emphasis"><em>Fail fast!</em></span> concepts are easy to use and contribute to more robust code and less development costs.</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compiled_language"></a>Compiled language</h2></div></div></div><p>A compiler translates the source code written by the programmer into executable binary code which is then executed.</p><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>During compilation a whole plethora of program errors are detected <span class="emphasis"><em>automatically</em></span>, thus contributing considerably to more reliable software.</p></li></ul></div><p>An additional benefit is that compiled code runs faster because the code doesn't have to be translated at runtime.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unit_testing"></a>Integrated unit testing </h2></div></div></div><p>Unit testing is a standard feature in Obix and supports test driven development (TDD).</p><p>Every script (function body) can have an associated test script that checks output values for any given set of input values. Moreover, every software component (type, factory or service) can have an associated test script that checks the functionally of the component as a whole.</p><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>Unit testing has proved without any doubts to be one of the most effective techniques to find bugs early.</p></li><li><p>Unit testing makes sure that an application still works correctly if code is refactored at a later time.</p><p>Suppose, for example, you want to refactor the source code of a software component that computes salaries, but that runs too slowly. Optimizing existing code that works is always a challenge and risks to introduce new errors. However, if good tests have been written, then you can confidently deliver your new version, because any error would immediately be reported after re-running the existing tests.</p></li><li><p>Besides testing correct results, unit testing can also be used to <span class="emphasis"><em>test correct error behavior</em></span>. For example, if a string contains 10 characters, then searching for a substring starting at character position 12 must raise an error.</p></li><li><p>Good test code provides excellent technical documentation in a precise, up-to-date and reliable way. It helps to understand the exact behavior of scripts and software components by examples of source code. This is especially important for boundary cases and exceptional situations.</p></li></ul></div><p>Example:</p><p>The following is an excerpt of a factory's test script that tests if a <code class="code">bank_account</code> object works properly</p><pre class="programlisting">   test
      script
         // create a customer
         var bank_customer bc = fa_bank_customer.create ( &amp;
            identifier = 10 &amp;
            name = "Foo" &amp;
            city = "Bar" )

         // create an account
         var bank_account account = create ( bc )

         // check customer attribute of account
         verify account.customer =r bc
         verify account.customer.name =v "Foo"

         // balance must be 0 after creation
         verify account.balance =v 0

         // add 100 to the account
         account.pay_in ( 100 )
         // verify balance
         verify account.balance =v 100
   
         // withdraw 70
         account.withdraw ( 70 )
         // verify balance
         verify account.balance =v 30

         // withdraw 10
         account.withdraw ( 10 )
         // verify balance
         verify account.balance =v 20

         // ...
      end script
   end test</pre><p>For more information and examples, please refer to <a href="testing.html" title="Chapter 21. Testing">Chapter 21, <i>Testing</i></a></p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="design_by_contract_contract_programming_2"></a>Contract programming (Design by Contract)</h2></div></div></div><p>Contract programming, also called Design by Contract (TM), is a very effective technique to find errors quickly <span class="emphasis"><em>at run-time</em></span>. It is therefore fully integrated in Obix.</p><p>The idea of contract programming is simple: Ensure that specific conditions, defined in the source code, are always fulfilled at run-time. There are 4 kinds of conditions:</p><div class="itemizedlist"><ul type="disc"><li>input conditions (preconditions): they protect commands against invalid input arguments</li><li>output conditions (postconditions): they ensure that commands return valid results</li><li>attribute conditions (class invariants): they define conditions that the state of an object (attribute values) must always fulfill</li><li>script conditions (asserts): these are conditions that are checked within a script</li></ul></div><p>The violation of any condition during run-time immediately results in a program error.</p><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>A typical application contains hundreds or thousands of contract programming conditions that are constantly verified when the application runs. Therefore, many program errors are detected quickly and automatically. This is most valuable when a programmer uses libraries not written by himself, such as Obix's standard libraries, or third-party libraries.</p><p>For example, contract programming is applied as follows in the standard libraries: If a script calls a <code class="code">string</code> command that extracts a substring from position <code class="code">from</code> to position <code class="code">to</code>, then both input arguments <code class="code">from</code> and <code class="code">to</code> cannot be void (null), and their values must be less or equal to the length of the string. Moreover, <code class="code">to</code> must be equal to or greater than <code class="code">from</code>. Furthermore, the result returned by the command cannot be void, and the length of the substring returned is guaranteed to be equal to <code class="code">to - from + 1</code>. A runtime error occurs immediately if any condition is violated.</p></li><li><p>Contract programming implicitly provides additional, precise, up-to-date, and reliable technical documentation. By looking at the conditions of a command's input and output arguments, for example, you can quickly understand how the command is to be used.</p></li></ul></div><p>Here is an example of contract programming used in Obix's standard library. Command <code class="code">restore_string_from_file</code> reads the text stored in a file into a <code class="code">string</code> variable:</p><pre class="programlisting">command restore_string_from_file
   in file type:file check: i_file.exists error_message: """File '{{i_file.path}}' doesn't exist""" error_id: file_not_found end
   in error_handler type:resource_error_handler default:se_system_utilities.default_resource_error_handler end

   out result type:string voidable:yes end
   out error type:file_error voidable:yes end
   out_check check: i_result =r void xor i_error =r void &amp;
      error_message: "o_result or else o_error must be void" &amp;
      error_id: result_xor_error_void_violation end</pre><p>An input condition is used to ensure that the file we want to read from actually exists (<code class="code">check: i_file.exists</code>). This condition is checked before executing the command. If it is violated at run-time, an error is generated immediately.</p><p>If the operation succeeds, the string is returned in output argument <code class="code">result</code> and output argument <code class="code">error</code> is void. If the file cannot be read for any reason, then <code class="code">result</code> will be void and the error will be reported in output argument <code class="code">error</code>. The output condition <code class="code">i_result =r void xor i_error =r void</code> is an exclusive <code class="code">or</code> ensuring that <code class="code">result</code> or else <code class="code">error</code> will be void.</p><p>A resource error handler can be provided by input argument <code class="code">error_handler</code>. This error handler is invoked if a file read error occurs. By default, the system's global resource error handler is used. By default this handler displays an error message on the system's <code class="code">error</code> device.</p><p>More information and examples can be found here: <a href="design_by_contract_contract_programming.html" title="Chapter 17. Contract Programming, also called Design by Contract (TM)">Chapter 17, <i>Contract Programming, also called Design by Contract (TM)</i></a></p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_and_strong_typing"></a>Static and strong typing</h2></div></div></div><p>The terms <em class="firstterm">static typing</em> and <em class="firstterm">strong typing</em> are not exactly defined in the literature, but in this context it means:</p><div class="itemizedlist"><ul type="disc"><li><p>Type checks are done at compile-time instead of being done at run-time.</p></li><li><p>The type of each object reference has to be explicitly defined in the source code. (Remark: an <span class="emphasis"><em>object reference</em></span> in Obix is a variable or constant in a script, an attribute of an object, or an input- or output-argument of a command.)</p></li></ul></div><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>All type incompatibility errors are detected at compile-time, instead of popping up randomly at run-time (hopefully not in production mode).</p><p>Example:</p><p>Consider the following code:</p><pre class="programlisting">const string level = se_security.get_current_level</pre><p>In this case, the programmer clearly assumes that command <code class="code">get_current_level</code> of service <code class="code">security</code> returns a string. If this assumption is false (for example because the value returned is in fact an integer or an enumerated), the compiler immediately generates an error, thus supporting the <span class="emphasis"><em>Fail fast!</em></span> rule. In a dynamically typed language this error would only be detected at run-time, and only at the time the above instruction is actually executed.</p><p>The advantage of compile-time checking is most valuable during maintainance or when code is refactored. For example, if command <code class="code">get_current_level</code> is changed later to return an object of type <code class="code">enumerated</code>, the compiler will quickly shout if the programmer forgets to adapt the above instruction, or any other dependant code. This helps to avoid maintenance nightmares. The compiler will automatically report all the places that have to be adapted, and the application cannot be redeployed unless all dependant code has been changed successfully. This kind of automatic error detection is of course especially important and effective in big projects were functions written by one programmer are used by other programmers.</p></li><li><p>The programmer's intention of what is to be stored in an object reference is clearly documented in the code and therefore eliminates ambiguities and makes the code more understandable for other programmers (and maybe for himself if he looks at it again two years later).</p><p>Example:</p><p>Consider the following function definition in a weakly typed language like Javascript:</p><pre class="programlisting">function get_user_privileges ( user, security_code, employee )</pre><p>There are a lot of ambiguities as to how to use this function, because the input arguments' types are not specified.</p><p>What is the <code class="code">user</code> input argument supposed to be? A simple string identifying the user, or maybe a <code class="code">user</code> object? What is the type requested for <code class="code">security_code</code>? Is it a <code class="code">string</code>, an <code class="code">integer</code>, or maybe something else? And so forth ...</p><p>What happens if we provide the wrong type (e.g. an <code class="code">integer</code> instead of a <code class="code">string</code>)? And what type of object, if any, is returned by <code class="code">get_user_privileges</code>?</p><p>Obviously, it helps a lot when we can see the types of objects required by and returned by a function.</p><p>In strongly typed languages, types must be specified for any object references, such as input and output arguments. In Obix, <code class="code">get_user_privileges</code> could be defined as follows:</p><pre class="programlisting">command get_user_privileges
   in user type:application_user end
   in security_code type:positive32 check:security_code &gt;= 1000 and security_code &lt;= 9999 end
   in employee type:yes_no default:no end

   out result type:user_privileges voidable:yes end
end</pre></li><li><p>The explicit definition of an object's type in the source code simplifies the development of tools and can increase the number of features a tool can provide.</p><p>Examples:</p><p>Static analysis tools like FindBugs (<a href="http://findbugs.sourceforge.net/" target="_top">http://findbugs.sourceforge.net/</a>) can find more bugs more easily if type information is directly available in the source code.</p><p>IDEs with immediate error checking during editing, automatic code completion, and quick code switching are easier to develop for statically typed languages.</p></li><li><p>Static typing leads to better performance, because the type information doesn't have to be evaluated and checked at run-time. Moreover the compiler can do several optimizations that are not possible in dynamically typed languages.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In rare cases, dynamic typing is required in applications. Therefore, Obix also supports dynamic typing, but the programmer's intention to use dynamic typing must be explicitly declared in the source code with the <code class="code">type_check:no</code> clause which is available for certain instructions.</p><p>Example:</p><pre class="programlisting">const string result = some_command type_check:no</pre><p>In this case the compiler doesn't check that <code class="code">some_command</code> actually returns a <code class="code">string</code>. But a run-time error appears if <code class="code">some_command</code> doesn't return a <code class="code">string</code>. Note: The compiler checks, however, that <code class="code">some_command</code> returns a <span class="emphasis"><em>parent</em></span> type of <code class="code">string</code>, because else the operation would be guaranteed to fail at run-time.</p><p>For even more flexibility, Obix's reflection mechanism allows to access object attributes and commands by specifying their name dynamically at run-time. For example, the name of a command to be executed at run-time could be stored (and modified) in an XML configuration file. In this case, a run-time error occurs if the command doesn't exist.</p><p>Finally, it is interesting to note that a whole source code script can be dynamically compiled and executed at run-time. This allows for very flexible customization of an application. For example, customer specific source code to compute a discount could be stored in a configuration file, and then be loaded and executed dynamically during run-time, without restarting the application.</p></td></tr></table></div><p>For more information about static typing, and an example of what can happen in practice if dynamic typing is used, please refer to <a href="static_typing.html" title="Chapter 16. Static typing">Chapter 16, <i>Static typing</i></a></p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="no_implicit_type_conversions"></a>No implicit type conversions</h2></div></div></div><p>There are no implicit type conversions (type casts) in Obix. Objects can be converted to another type only by explicit instructions, for example by calling an object command that converts the object.</p><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>Automatic type casts don't exist in Obix because they are error-prone. They can lead to unexpected results if the programmer is not aware of the compiler's internal conversion rules. Type conversion rules can be complex and counter-intuitive, poorly documented and compiler-specific.</p></li></ul></div><p>Example:</p><p>What will be printed by the following valid Java code?</p><pre class="programlisting">System.out.println ( "50 + 50 = " + 50+50 );</pre><p>Most programmers quickly reply: The output will be <code class="code">50 + 50 = 100</code>.</p><p>However, the actual output is <code class="code">50 + 50 = 5050</code>.</p><p>The reason is that the two integers are implicitly converted to strings and then appended as strings.</p><p>The compiler <span class="emphasis"><em>could</em></span> also first evaluate <code class="code">50+50</code> and then convert the result to a string and append it. The problem is that there exists an ambiguity as to what the compiler actually does. In this case, the actual result is counter-intuitive (at least for many programmers), and therefore error-prone.</p><p>That's the reason why implicit casts don't exist in Obix. The following instruction in Obix would generate a compile-time error:</p><pre class="programlisting">system.out.write_line ( "50 + 50 = " &amp; 50+50 )</pre><p>To avoid confusion and produce the correct output, the integer result has to be explicitly converted to a string, as follows:</p><pre class="programlisting">system.out.write_line ( "50 + 50 = " &amp; (50+50).to_string )</pre><p>This will display:</p><pre class="screen">50 + 50 = 100</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Please note the two different operators <code class="code">&amp;</code> and <code class="code">+</code> used in the above instruction. <code class="code">&amp;</code> is used to <span class="emphasis"><em>append</em></span> objects, and <code class="code">+</code> is used to <span class="emphasis"><em>add</em></span> objects.</td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="case_type_of"></a>The <code class="code">case type of</code> instruction</h2></div></div></div><p>The <code class="code">case type of</code> instruction can be used whenever a computation depends on the actual subtype of an object at run-time.</p><p>The compiler checks that each existing subtype is considered exactly once, and reports any violations.</p><p>Example:</p><p>Type <code class="code">product</code> has 3 sub-types: <code class="code">fruit</code>, <code class="code">vegetable</code>, and <code class="code">book</code>. Suppose that we have to compute the number of objects of each type of product in a shopping basket. In this case the <code class="code">case type of</code> instruction should be used to identify the type of each product in the basket and then increment an appropriate counter. The code that iterates through the basket and increments the counters looks as follows:</p><pre class="programlisting">// initialize counters to 0
var zero_positive32 fruit_count; vegetable_count; book_count = 0

// loop over all items in shopping basket
repeat for each product item in shopping_basket

   case type of item

      when fruit then                           // if it is a fruit
         fruit_count = fruit_count + 1          // then increment fruit counter

      when vegetable then                       // if it is a vegetable
         vegetable_count = vegetable_count + 1  // then increment vegetable counter

      when book then                            // if it is a book
         book_count = book_count + 1            // then increment book counter

  end case

end repeat</pre><p>Rationale:</p><div class="itemizedlist"><ul type="disc"><li><p>The compiler checks that each subtype is considered exactly once in the <code class="code">when</code> clauses. This means that the following errors are detected at compile-time:</p><div class="itemizedlist"><ul type="circle"><li>A subtype is omitted. For example, the programmer forgets to include type <code class="code">book</code> in the above example.</li><li>A subtype appears in more than one <code class="code">when</code> clauses, which leads to ambiguities.</li><li>A type which is not a subtype of the tested object appears in a <code class="code">when</code> clause. For example, <code class="code">when employee then ...</code> would be refused in the above code, because <code class="code">employee</code> is not a sub-type of <code class="code">product</code> (we suppose that employees are not sold in a shopping basket).</li></ul></div></li><li><p>The compiler's checks are especially useful if new subtypes are added later in the application.</p><p>For example, if type <code class="code">game</code> is later added as a subtype of <code class="code">product</code>, the compiler automatically reports all <code class="code">case type of</code> instructions that have not been adapted to include the new type. Again, this <span class="emphasis"><em>Fail fast!</em></span> concept is of course most useful in big projects. Imagine what could happen without the <code class="code">case type of</code> instruction if one programmer adds a type, and 'forgets' to inform all other programmers that they have to adapt their code!</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="more%20concepts"></a>More reliability concepts</h2></div></div></div><p>The following table briefly enumerates other reliability concepts that will be explained more thoroughly in a future version of this article.</p><div class="table"><a name="concepts"></a><p class="title"><b>Table 1. 'Fail fast' concepts in Obix</b></p><div class="table-contents"><table summary="'Fail fast' concepts in Obix" cellspacing="0" cellpadding="5" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Concept</th><th>Rationale</th><th>Link</th></tr></thead><tbody><tr><td>Void values not allowed by default</td><td>helps to find some errors at compile-time, and many errors early at run-time</td><td><a href="void_values.html" title="Chapter 12. Void values">Chapter 12, <i>Void values</i></a></td></tr><tr><td>Feature redefinition in child types</td><td>leads to a more expressive and safer typing system; helps to find errors at compile-time</td><td><a href="feature_redefinition.html" title="Chapter 18. Feature redefinition">Chapter 18, <i>Feature redefinition</i></a></td></tr><tr><td>Generic types</td><td>more type safety and no error-prone casts at run-time; helps to find errors at compile-time</td><td><a href="generic_types.html" title="Chapter 19. Generic types">Chapter 19, <i>Generic types</i></a></td></tr><tr><td>Objects are immutable by default</td><td>simplifies objects and makes them less error-prone; also makes them thread-safe and therefore usable in parallel processing without the need of synchronization</td><td><a href="object_immutability.html" title="Chapter 14. Object immutability">Chapter 14, <i>Object immutability</i></a></td></tr><tr><td>Everything is an object</td><td>eliminates different behavior between primitive types, arrays and 'real' objects</td><td> </td></tr><tr><td>Arithmetic overflow errors caught immediately</td><td>eliminates evil consequences of arithmetic overflows</td><td> </td></tr><tr><td>Enumerated types</td><td>type-safe enumerateds; more errors detected at compile-time</td><td><a href="enumerated_type.html" title="Chapter 11. Enumerated type">Chapter 11, <i>Enumerated type</i></a></td></tr><tr><td>the 'case enumerated of' instruction</td><td>ensures to detect 'I forgot that enumerated value' errors at compile-time</td><td>(not yet available)</td></tr><tr><td>No positional argument passing</td><td>
              <p>
                </p><pre class="programlisting">set_color ( 255, 0, 255, 50 )</pre><p>
                is less clear and more error-prone than
                </p><pre class="programlisting">set_color ( &amp;
   red   = 255 &amp;
   green = 0   &amp;
   blue  = 255 &amp;
   opacity_percent = 50 )</pre><p>, isn't it?</p>
            </td><td> </td></tr><tr><td>Libraries</td><td>All <span class="emphasis"><em>Fail fast!</em></span> concepts are consistently used in Obix's standard libraries, so that every application benefits from it.</td><td> </td></tr><tr><td>Robust Java code</td><td>Under the hood, robust, proven and standard Java code is executed for all common operations such as string and file manipulations, collections, servlets and JSPs, and so on. If needed, you can use any existing Java library in an Obix application.</td><td><a href="embedded_java.html" title="Chapter 10. Embedded Java source code">Chapter 10, <i>Embedded Java source code</i></a></td></tr><tr><td>Error handling</td><td>Obix's error handling aims to be intuitive, easy to use and flexible; see link for further information</td><td><a href="error_handling.html" title="Chapter 13. Runtime error handling">Chapter 13, <i>Runtime error handling</i></a></td></tr><tr><td>Types, factories and services</td><td>enforces implementation hiding and simplifies the design of software components</td><td><div class="literallayout"><p><a href="RSEs.html#type" title="Type">the section called &#8220;Type&#8221;</a><br>
  <a href="factory.html" title="Factory">the section called &#8220;Factory&#8221;</a><br>
  <a href="service.html" title="Service">the section called &#8220;Service&#8221;</a></p></div></td></tr><tr><td>Multiple type inheritance</td><td>leads to better design and simpler types; a proven and required concept of Object Oriented (OO) programming languages</td><td><a href="type_inheritance.html" title="Chapter 15. Type inheritance">Chapter 15, <i>Type inheritance</i></a></td></tr><tr><td>Default values for attributes and input arguments</td><td>simplifies object creation and command execution</td><td><div class="literallayout"><p><a href="RSE_features.html#attribute_default_property" title="Attribute property default">the section called &#8220;Attribute property <code class="code">default</code>&#8221;</a><br>
  <a href="command.html#input_argument_default_property" title="Input argument property default">the section called &#8220;Input argument property <code class="code">default</code>&#8221;</a></p></div></td></tr><tr><td>Multiple output arguments</td><td>simplifies resource error handling; avoids using input arguments or creating new types to store multiple results</td><td><a href="resource_error.html" title="Resource error">the section called &#8220;Resource error&#8221;</a></td></tr><tr><td>Source code templates</td><td>avoids code duplication</td><td><a href="source_code_templates.html" title="Chapter 20. Source code templates">Chapter 20, <i>Source code templates</i></a></td></tr><tr><td>Explicit declaration of variables and constants</td><td>Variables and constants in scripts have to be explicitly declared before they can be used</td><td> </td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="why_obix.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="obix_articles.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="introduction_to_obix.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Why Obix? Reliable code and software developer productivity </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The Obix programming language: more reliable code in less time</td></tr></table></div></body></html>
