<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 7. Object immutability</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="advanced_concepts.html" title="Part II. Concepts for more reliable code"><link rel="prev" href="void_values.html" title="Chapter 6. Void values"><link rel="next" href="static_typing.html" title="Chapter 8. Static typing"><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29648172-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Object immutability</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="void_values.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><th width="60%" align="center">Part II. Concepts for more reliable code</th><td width="20%" align="right"> <a accesskey="n" href="static_typing.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="object_immutability"></a>Chapter 7. Object immutability</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Please note that this chapter is incomplete. An update will be published in the future.</td></tr></table></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object_immutability_description"></a>Description</h2></div></div></div><p>By default all objects are <span class="emphasis"><em>immutable</em></span> in Obix. This means that, once an object is created or a service is initialized, their attributes cannot be set to another value.</p><p>If needed, attributes can explicitly be made mutable.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object_immutability_rules"></a>Rules</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>By default, all attributes defined in an RSE (type, factory or service) are immutable.</em></span></p><p>This signifies that:</p><div class="itemizedlist"><ul type="disc"><li><p>once an object is created, it is not possible to set an attribute to another value.</p></li><li><p>once a service is initialized, it is not possible to set an attribute to another value.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This rule is checked at compile-time and also applies to private attributes in factories and services.</p><p></p></td></tr></table></div></li><li><p><span class="emphasis"><em>An attribute can explicitly be declared as mutable through the attribute's <code class="code">kind</code> property.</em></span></p><p>Keeping all attributes immutable is sometimes inappropriate or impossible. For example, a customer's identifier is typically immutable, but its address can change, therefore it makes sense to make attribute <code class="code">address</code> mutable.</p><p>Please refer to <a href="RSE_features.html#attribute_kind_property" title="Attribute property kind">the section called &#8220;Attribute property <code class="code">kind</code>&#8221;</a> for more information about how to use property <code class="code">kind</code></p><p>Here is a reprint of the example used in that section:</p><pre class="programlisting">type person
   attribute first_name type:string kind:constant end            // first name never changes
                                                                 // ('kind:constant' could be omitted, 
                                                                 // because 'constant' is default value for 'kind')
   attribute last_name type:string kind:variable end             // last name can change, e.g. when woman gets maried
   attribute birthdate type:date end                             // birthdate never changes ('kind' defaults to 'constant')
   attribute age type:zero_positive32 kind:readonly_variable end // age changes each year, and depends on birthdate
end type</pre></li><li><p><span class="emphasis"><em>If an attribute is mutable then its <code class="code">setable</code> property defines which software elements are allowed to change the attribute.</em></span></p><p>Please refer to <a href="RSE_features.html#attribute_setable_property" title="Attribute property setable">the section called &#8220;Attribute property <code class="code">setable</code>&#8221;</a> for more information about how to use property <code class="code">setable</code></p><p>Here is a reprint of the example used in that section:</p><pre class="programlisting">type person_2 default_factory:yes

   attribute_list type:string

      attribute first_name end             // attribute is immutable. it can only be set in the creator.
                                           // (property 'kind' defaults to 'constant', in which case
                                           // property 'setable' defaults to 'creator')
      attribute last_name &amp;
         kind:variable setable:factory end // only scripts in the factory that creates the object can change 'last_name'

      attribute city &amp;
         kind:variable setable:all end     // any script can change the value

   end attribute_list

end type</pre></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is important to be aware of the fact that an immutable object can possibly have attribute values which are themselves mutable. In such a case the object's attributes cannot be set to another value, but an attribute of an attribute (i.e. a child-attribute) can still change its value.</p><p>Suppose, for example, an immutable list containing 3 customers. Suppose also that attribute <code class="code">address</code> of type <code class="code">customer</code> is mutable. In this case, the customers contained in the list will always remain the same, but any customer's address can  change.</p><p>It follows from the above that it can sometimes be important to consider whether all attributes of an immutable object are themselves recursively immutable. If they are, then the object is said to be <span class="emphasis"><em>deeply immutable</em></span>.</p></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object_immutability_rationale"></a>Rationale</h2></div></div></div><p>The advantages of immutable objects are very well explained in chapter <em class="citetitle">Favor immutability</em> in Joshua Bloch's excellent book <em class="citetitle">Effective Java</em> (ISBN 0-201-31005-8).</p><p>Joshua Bloch concludes (on page 70): [<span class="citation">Classes should be immutable unless there is a very good reason to make them mutable!</span>]</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is interesting to note that objects are <span class="emphasis"><em>mutable</em></span> by default in most languages. Java Beans for example impose mutable objects, because the bean specification requires a default no-argument constructor, and a setter-method for each property (attribute).</p></td></tr></table></div><p>Obix favors immutability for the following reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>Immutable objects are simple: Once created with all attributes set to valid values, their state doesn't change anymore and remains valid all the time. There are no state transitions to manage. Therefore, immutable objects are less error-prone.</p></li><li><p>Immutable objects are thread-safe. They don't require synchronization.</p><p>Let's look at 2 examples of what can happen if <span class="emphasis"><em>mutable</em></span> objects are used in a multi-threaded environment.</p><p>Consider the following naive and oversimplified type for mutable dates:</p><pre class="programlisting">type mutable_date

   attribute_list type:positive32 kind:variable setable:all
   
      attribute day   check: i_day &lt;= 31   end
      attribute month check: i_month &lt;= 12 end
      attribute year  end
      
   end

end</pre><p>Now suppose this type is used to hold the estimated delivery date for a customer's order, and the following happens:</p><div class="orderedlist"><ol type="1"><li><p>the initial estimated delivery date is set to 31.1.2008 (31th January 2008).</p></li><li><p>later on the date changes to 15.2.2008 (15th February 2008).</p><p>the software does this by:</p><div class="itemizedlist"><ul type="circle"><li><p>first changing the day from 31 to 15.</p></li><li><p>then changing the month from 1 to 2.</p></li></ul></div><p>the instructions might look like this:</p><pre class="programlisting">estimated_delivery_date.day = 15
estimated_delivery_date.month = 2</pre></li><li><p>at the same time another thread reads the order's estimated delivery date in order to send an email confirmation to the customer.</p><p>the instruction might look like this:</p><pre class="programlisting">mail_message = "estimated delivery time: " &amp; customer_order.estimated_delivery_date.to_string</pre></li></ol></div><p>The problem with this code appears when the second thread reads the date after the day has been changed by the first thread, but before the month is changed. In that case, the date sent to the customer will be 15.1.2008, instead of 15.2.2008!</p><p>Even worse, if the same happened with an initial date of 15.2.2008, and an updated value of 31.3.2008, then the date sent to the customer would be 31.2.2008, which is not only a wrong date, but also an illegal date!</p><p>Another example: An accounting application includes a list containing the history of all accounting records. Task 1 appends a new operation by adding two records, one credit record and one debit record. Task 2 scans the list in order to print a balance sheet. Scanning is done after task 1 added the first record and before adding the second record of the new operation. The terrible consequence is that the balance will be unbalanced, because only the first record of the new operation is included in the scanning!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is really important to note that problems like the above ones count among the nastiest ones that can appear in practice. The reason is that they typically appear randomly and rarely, and they frequently just produce wrong results, but no run-time errors. This makes them often extremely difficult to detect, repeat and debug. They might stay undetected during the test phase, and afterwards the most bizarre phenomenon can appear randomly once the software is in production, where more users create more data in different environments.</p><p></p></td></tr></table></div></li><li><p>Immutable objects can freely be shared. There is no need for creating copies of immutable objects, because their state can simply not change during the whole lifetime of the object. As a nice side-effect, this can sometimes considerably increase performance.</p></li><li><p>If a command's input argument is immutable, there is no risk of inadvertently (or voluntary) changing the input argument's state within the command.</p></li><li><p>Immutable objects are less vulnerable to malicious attacks, because evil code cannot change the state of immutable objects.</p></li></ul></div><p>Despite the advantages of immutable objects, it does not always make sense to make objects immutable.</p><p>In some situations it is even impossible. For example, if two objects mutually refer to each other. A concrete example would be a tree with each node holding a reference to its parent node and its child nodes.</p><p>Another issue is that immutable types require a different object for each distinct value. Hence, each time the state changes, a new object has to be created, which can be too much time and space consuming. Consider, for example, a list containing all accounting records. Every time a new records was added, a new list would have to be created. Obviously, in a real-world application with thousands or millions of records, all memory resources would quickly be consumed and the performance would drop down to an unacceptable level.</p><p>Quite often, the best solution is to provide an immutable type together with a mutable counterpart. The mutable type is first used to build an object. Then, once the object doesn't change anymore it is converted into its immutable counterpart.</p><p>This method of first using a mutable type to build an object and then convert it into an immutable one (e.g. with command to_immutable) is largely supported in Obix's standard library.</p><p>The following code shows an example of creating an immutable list by first using a mutable list and then converting it to an immutable one:</p><div class="example"><a name="object_immutability_example"></a><p class="title"><b>Example 7.1. Building an immutable list</b></p><div class="example-contents"><pre class="programlisting">service geographical_data

   attribute list_of_continents type:!indexed_list&lt;string&gt; // immutable list of continents
      default
         script
            // declare mutable list
            const !mutable_indexed_list&lt;string&gt; result = !mutable_indexed_list_factory&lt;string&gt;.create

            // append items
            result.append ( "Africa" )
            result.append ( "Antartica" )
            result.append ( "Asia" )
            result.append ( "Australia" )
            result.append ( "Europe" )
            result.append ( "North America" )
            result.append ( "South America" )
            
            // convert to immutable list
            o_list_of_continents = result.to_immutable
         end
      end
   end

end</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object_immutability_see_also"></a>See also</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><a href="RSE_features.html#attribute_kind_property" title="Attribute property kind">the section called &#8220;Attribute property <code class="code">kind</code>&#8221;</a></li><li><a href="RSE_features.html#attribute_setable_property" title="Attribute property setable">the section called &#8220;Attribute property <code class="code">setable</code>&#8221;</a></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="void_values.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><td width="20%" align="center"><a accesskey="u" href="advanced_concepts.html"><img src="images/up.png" alt="Go up one level" title="Go up one level"></a></td><td width="40%" align="right"> <a accesskey="n" href="static_typing.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 6. Void values </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Table of contents" title="Table of contents"></a></td><td width="40%" align="right" valign="top"> Chapter 8. Static typing</td></tr></table></div></body></html>
