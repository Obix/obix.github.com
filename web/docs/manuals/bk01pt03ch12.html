<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 12. Void values</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="bk01pt03.html" title="Part III. Advanced concepts"><link rel="prev" href="bk01pt03ch11.html" title="Chapter 11. Enumerated type"><link rel="next" href="bk01pt03ch13.html" title="Chapter 13. Runtime error handling"><script type="text/javascript">
        
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-22290805-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 12. Void values</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01pt03ch11.html">Prev</a> </td><th width="60%" align="center">Part III. Advanced concepts</th><td width="20%" align="right"> <a accesskey="n" href="bk01pt03ch13.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="void_values"></a>Chapter 12. Void values</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="void_values_description"></a>Description</h2></div></div></div><p>Obix handles void values in a way that sustains the important <span class="emphasis"><em>"fail fast!"</em></span> principle, as described below.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="void_values_rules"></a>Rules</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>Any object reference (attribute, input argument, output argument, constant and variable) can basically be set to <code class="code">void</code>, which means that no object is attached to the object reference.</em></span></p></li><li><p><span class="emphasis"><em>By default, void values are not allowed for attributes, input arguments and output arguments</em></span>.</p><p>This means that a program error is raised immediately whenever:</p><div class="itemizedlist"><ul type="disc"><li><p>an object is created with any attribute set to <code class="code">void</code></p></li><li><p>a service is initialized with any attribute set to <code class="code">void</code></p></li><li><p>a command is called with any input argument set to <code class="code">void</code></p></li><li><p>a command returns with any output argument set to <code class="code">void</code></p></li></ul></div></li><li><p><span class="emphasis"><em>The ability to allow or disallow void values is defined through the object reference's property <code class="code">voidable</code> which can be set to <code class="code">yes</code> or <code class="code">no</code>. The default value is <code class="code">no</code>.</em></span></p><p>In the following example of a type that defines a product, the value of attribute <code class="code">price_in_cents</code> is allowed to be <code class="code">void</code> at runtime (<code class="code">voidable:yes</code>), but all other attributes cannot be <code class="code">void</code>.</p><div class="informalexample"><pre class="programlisting">type product_3 default_factory:yes

   attribute identifier type:positive32 end
   attribute name type:string end
   attribute price_in_cents type:positive32 voidable:yes end
   
end</pre></div></li><li><p><span class="emphasis"><em>A compile-time error is generated whenever <code class="code">void</code> is assigned to an attribute or input argument with property <code class="code">voidable</code> set to <code class="code">no</code> (default value).</em></span></p><p>For example, the following instruction used to create an object of the above listed type generates a compile-time error, because attribute <code class="code">name</code> is not allowed to be <code class="code">void</code>.</p><pre class="programlisting">const product_3 product = fa_product_3.co_create ( &amp;
   identifier = 123 &amp;
   name = void &amp;
   price_in_cents = void )</pre></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="void_values_rationale"></a>Rationale</h2></div></div></div><p>The rule <span class="emphasis"><em>"by default void values are not allowed"</em></span> is built into Obix for the following reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>not allowing void values is what we actually want in most cases, so the default behavior is adequate.</p></li><li><p>the rule greatly sustains the <span class="emphasis"><em>"fail fast"</em></span> principle, which is <span class="emphasis"><em>the</em></span> fundamental principle applied again and again in Obix in order to help writing more reliable and maintainable code.</p><p>To illustrate this, suppose that type <code class="code">person</code> has attribute <code class="code">brain</code>. Suppose also that Obix's default behavior would be the same than those of most programming languages, which means that:</p><div class="itemizedlist"><ul type="circle"><li><p>void values are allowed for attributes</p></li><li><p>attributes are mutable (i.e. their value can be changed after the object has been created)</p></li></ul></div><p>Suppose finally that variable <code class="code">buddy</code> contains an instance of <code class="code">person</code>.</p><p>In that case the instruction</p><pre class="programlisting">buddy.brain = void</pre><p>wouldn't generate a compile-time error, and, even worse, it wouldn't generate a run-time error. A run-time error would only appear later whenever a feature of <code class="code">brain</code> is needed, such as</p><pre class="programlisting">buddy.brain.think</pre><p>The big problem with this behavior is that the initial design error is not detected at compile-time, it is also not guaranteed to be detected at run-time, and if it is detected at run-time, debugging can get really difficult, because the effect of the error can appear late after the object's creation, and it can appear anywhere in the source code, not only in the part that contains the root of the error. Moreover, what makes this runtime error such a pain is that tracking down its cause can be very frustrating, because the displayed error message often contains little or no information about the error's 'birth' (usually a void value assigned much earlier in the code, possibly even in another package written by someone else).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Experience shows that executing a feature on a void object is certainly one of the most frequent run-time errors in languages that apply the opposite rule, namely: <span class="emphasis"><em>"void values are allowed by default"</em></span>. For example, most Java programmers would probably agree that the <code class="code">NullPointerException</code> exception appears more often than any other one.</p></td></tr></table></div><p>Whenever appropriate, Obix's standard library makes heavy use of the <span class="emphasis"><em>"void values are not allowed"</em></span> principle. For example, when a <code class="code">void</code> input value would result in an undefined, or questionable result, then <code class="code">void</code> is simply not allowed. For instance, what should be the result of the boolean operation <code class="code">a or b</code>, if <code class="code">b</code> is <code class="code">void</code>. Some languages just return <code class="code">false</code>, others return <code class="code">void</code> (or <code class="code">null</code>). Obix follows the <span class="emphasis"><em>"fail fast!"</em></span> rule and therefore doesn't allow the operation to be executed, because <code class="code">void</code> is an invalid value for <code class="code">b</code>.</p></li><li><p>As the permission for <code class="code">void</code> values has to be explicitly specified in the source code (by writing <code class="code">voidable:yes</code>), programmers are more aware of that fact and are thus encouraged to pay attention to it, for example by first checking an expression for <code class="code">void</code> before assigning it to an attribute or input argument.</p></li><li><p>In case of a type, the permission for <code class="code">void</code> is simply specified in the type's source code through the <code class="code">voidable</code> property. Therefore, factories implementing types don't need to explicitly check for <code class="code">void</code> values. Obix automatically takes care of that. For example, if a type's command input argument cannot be void there is no need for a check in the factories' implementation code.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In Java, for example, whenever an input argument for an interface's method is not allowed to be null, then there is no way to specify this in the interface. Hence, each class implementing that interface must check for null with an explicit statement for each input argument, such as:</p><pre class="programlisting">if (input == null) {
   throw new IllegalArgumentException("input cannot be null");
}</pre></td></tr></table></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">There have been suggestions to completely eliminate void values by providing special objects used to represent void or inexistent values, so-called null objects. The argument is that this eliminates the need for testing for void, and also suppresses the NullPointerException. However, there are some rejoinders. First, the idea of an object which is not a 'real object' seems to be unnatural. It is like having in a garage a strange kind of car which is not a real car. Secondly, not discerning real values from fake values introduces new sources for bizarre errors which can be even more difficult to detect than errors due to void values, because the effect will possibly be more distanced from its cause. However, if a programmer likes the idea of fake objects or if there are some good reasons to use them, nothing prevents her from applying them in Obix. For example, it might be appropriate to inhibit a void value for an attribute of type list, and then assign an empty list instead of a void value whenever there are no items in the list.</td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="void_values_see_also"></a>See also</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt02ch06.html#attribute_voidable_property" title="Attribute property voidable">the section called &#8220;Attribute property <code class="code">voidable</code>&#8221;</a> (attribute)</li><li><a href="bk01pt02ch06s02.html#argument_voidable_property" title="Argument property voidable">the section called &#8220;Argument property <code class="code">voidable</code>&#8221;</a> (input/output argument)</li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01pt03ch11.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="bk01pt03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bk01pt03ch13.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 11. Enumerated type </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 13. Runtime error handling</td></tr></table></div></body></html>
