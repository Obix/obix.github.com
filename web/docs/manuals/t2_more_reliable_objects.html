<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Step 4: Making data more reliable and secure</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="random_arcs_application.html" title="Chapter 7. The 'Random arcs' application"><link rel="prev" href="t2_advantages.html" title="Advantages (so far)"><link rel="next" href="t2_object_conversion.html" title="Step 5: Object conversions and error handling"><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29648172-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Step 4: Making data more reliable and secure</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="t2_advantages.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><th width="60%" align="center">Chapter 7. The 'Random arcs' application</th><td width="20%" align="right"> <a accesskey="n" href="t2_object_conversion.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="t2_more_reliable_objects"></a>Step 4: Making data more reliable and secure</h2></div></div></div><p>So far we have written code to create <code class="code">contribution</code> objects. However, we are not done yet if we want to create <span class="emphasis"><em>reliable and secure</em></span> objects because:</p><div class="itemizedlist"><ul type="disc"><li><p>We stated initially that the random value used for an arc's radius can vary between 1 and 15. However, attribute <code class="code">random_number</code> is currently of type <code class="code">positive32</code> which means that there is no protection against assigning values greater than 15.</p></li><li><p>Attributes <code class="code">first_name</code> and <code class="code">last_name</code> are both of type <code class="code">string</code>. Besides allowing for nonsense names like <code class="code">#!314$</code> this opens the door for invalid and malicious data. For example too long names can lead to <a href="http://en.wikipedia.org/wiki/Buffer_overflow" target="_top">buffer overflow</a> problems and attacks, and the acceptance of invalid characters in the names (such as &lt; and &gt;) can lead to <a href="http://en.wikipedia.org/wiki/SQL_injection" target="_top">SQL injection</a> and <a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_top">cross-site scripting</a> attacks.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Preventing bad data to be stored in objects is one of the most effective ways to construct reliable and secure software. According to the <a href="https://www.owasp.org" target="_top">Open Web Application Security Project</a> (OWASP), <span class="emphasis"><em>injection</em></span> and <span class="emphasis"><em>cross-site-scripting</em></span> are the two top items in their list of <a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Project" target="_top">Top ten security risks</a></td></tr></table></div><p>Luckily Obix makes it easy to define specific types that protect against invalid data.</p><br><p>A solution for attributes <code class="code">first_name</code> and <code class="code">last_name</code> is to define a new type that holds a string composed only of letters and spaces, and limited to a length of 40 characters. Let's call this type <code class="code">user_name</code>. Create it like this:</p><div class="itemizedlist"><ul type="disc"><li><p>Create a new source code file named <code class="code">ty_user_name.osc</code> in subdirectory <code class="code">li_contribution</code>.</p></li><li><p>Insert the following code:</p><pre class="programlisting">type user_name default_factory:yes

   inherit simple_non_empty_string
      attribute value and_check:i_value.matches_regex ( fa_regex.create ( "^[a-zA-Z ]{1,40}$"~ ) ) end
   end
   
end</pre></li></ul></div><p>In the above code we use several techniques:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="type_inheritance.html" title="Chapter 12. Type inheritance">Type inheritance</a> is used to inherit from type <code class="code">simple_non_empty_string</code> which is defined in Obix's standard library. As the name suggests, <code class="code">simple_non_empty_string</code> is a string that cannot be empty.</p></li><li><p>We then use a combination of <a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Feature redefinition in child types</a> and <a href="design_by_contract_contract_programming.html" title="Chapter 4. Contract Programming, also called Design by Contract (TM)">Contract Programming (Design by Contract)</a> to specify a new validation rule for type <code class="code">user_name</code>. Besides requiring that the string value cannot be empty the value must also match the <a href="http://en.wikipedia.org/wiki/Regular_expression" target="_top">regular expression</a> <code class="code">^[a-zA-Z ]{1,40}$</code> in order to guarantee that a user name can only contain letters and spaces, and cannot exceed 40 characters.</p></li><li><p>The <code class="code">default_factory:yes</code> clause relieves you from explicitly defining a factory for type <code class="code">ty_user_name</code>. The compiler will create a default factory with identifier <code class="code">fa_user_name</code> and a creator named <code class="code">create</code> which you can use to create <code class="code">user_name</code> objects.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">This chapter and the following one introduce a number of techniques which are unique to Obix. Please note that the details of these techniques are not fully explained in this tutorial. The aim is to give you a quick overview about the techniques available in Obix, without digging too deep. Please refer to the links in the text, the <a href="language_manual.html" title="Obix programming language manual">language manual</a>, the <a href="http://www.rps-obix.com/docs/API/API_intro.html" target="_top">API documention</a> and the system source code if you need more information, or post a message in the Obix forum.</td></tr></table></div><p>Types that hold string values restricted by a regular expression are very common. Just think of things like a telephone number, an email adress, an ISBN number, etc. Therefore Obix's standard library contains a <a href="source_code_templates.html" title="Chapter 13. Source code templates">source code template</a> you can use in order to minimize the code to type and to avoid code duplication. The template that shortens our code is named <code class="code">non_empty_regex_string_type</code>. Its source code is defined as follows:</p><pre class="programlisting">template non_empty_regex_string_type

   param type_suffix end
   param regex end

   type {type_suffix} default_factory:yes

      inherit simple_non_empty_string
         attribute value
            and_check
               script
                  const regex regex = fa_regex.create ( "{regex}"~ )
                  check i_value.matches_regex ( c_regex ) &amp;
                     error_message: """'{{i_value.to_string}}' is invalid because it doesn't match the regular expression '{{c_regex}}'""" &amp;
                     error_id: matches_regex_violation
               end
            end
         end
      end
   end
   
end</pre><p>This template has two parameters:</p><div class="orderedlist"><ol type="1"><li><p><code class="code">type_suffix</code> is the type suffix of the type we want to create</p></li><li><p><code class="code">regex</code> is the regular expression to apply in the type</p></li></ol></div><p>To use this template replace the content of file <code class="code">ty_user_name.osc</code> with:</p><pre class="programlisting">%non_empty_regex_string_type &lt; &amp;
   type_suffix: "user_name" &amp;
   regex: "^[a-zA-Z ]{1,40}$" &gt;</pre><br><p>What remains to be done is to change the type of attributes <code class="code">first_name</code> and <code class="code">last_name</code> in type <code class="code">contribution</code> from <code class="code">string</code> to <code class="code">user_name</code>.</p><p>Replace the old code:</p><pre class="programlisting">attribute first_name type:string end
attribute last_name  type:string end</pre><p>with this one:</p><pre class="programlisting">attribute first_name type:user_name end
attribute last_name  type:user_name end</pre><p>Remark: Don't re-compile now. Wait until the end of this chapter.</p><br><p>We can now use the same technique to restrict attribute <code class="code">random_number</code> to values between 1 and 15:</p><div class="itemizedlist"><ul type="disc"><li><p>Create a new source code file named <code class="code">ty_random_1_15.osc</code> in subdirectory <code class="code">li_contribution</code>.</p></li><li><p>Insert the following code:</p><pre class="programlisting">type random_1_15

   inherit simple_positive32
      attribute value and_check: i_value &lt;= 15~ error_message: "Value must be between 1 and 15" end
   end
   
end</pre></li></ul></div><p>Types that hold positive integer numbers limited to a maximum value are also very common. Therefore you can again use a template in Obix's standard library in order to simplify the code and avoid code duplication. Replace the above code with:</p><pre class="programlisting">%positive32_with_maximum_type &lt; &amp;
   type_suffix: "random_1_15" &amp;
   max_value: "15~" &gt;</pre><p>You might have noticed that the clause <code class="code">default_factory:yes</code> is used in type <code class="code">user_name</code>, but not in type <code class="code">random_1_15</code>. The reason is that we will later need to customize factory <code class="code">random_1_15</code>. Therefore we can't use the default factory created by the compiler with the <code class="code">default_factory:yes</code> clause. Hence define the factory explicitly as follows.</p><div class="itemizedlist"><ul type="disc"><li><p>Create a new source code file named <code class="code">fa_random_1_15.osc</code> in subdirectory <code class="code">li_contribution</code>.</p></li><li><p>Insert the following code:</p><pre class="programlisting">factory random_1_15 type:random_1_15

   creator create kind:in_all end
   
end</pre></li></ul></div><p>Finally you have to change the declaration of attribute <code class="code">random_number</code> in type <code class="code">contribution</code>.</p><p>The old code:</p><pre class="programlisting">attribute random_number type:positive32 end</pre><p>becomes:</p><pre class="programlisting">attribute random_number type:random_1_15 end</pre><br><p>Because we have now changed the types of 3 attributes in type <code class="code">contribution</code> we have to adapt the test script in factory <code class="code">contribution</code>. The type of attribute <code class="code">first_name</code>, for example, changed from <code class="code">string</code> to <code class="code">user_name</code>. Therefore we can't assign anymore a string literal (like <code class="code">"Albert"</code>) to <code class="code">first_name</code>. Static typing requires us to use an object of type <code class="code">user_name</code>, and such an object can be created with the syntax <code class="code">fa_user_name.create ( "Albert"~ )</code>. Please note the ~ symbol in this expression. Writing <code class="code">"Albert"</code> denotes a <code class="code">string</code> literal, whereas <code class="code">"Albert"~</code> denotes a <code class="code">string_value</code> literal.</p><p>The code below shows the adapted code of the factory's test script. Please note the changes made for attributes <code class="code">first_name</code>, <code class="code">last_name</code> and <code class="code">random_number</code> and adapt your source code file:</p><pre class="programlisting">   test
      script
         // create a 'contribution' object and assign it to constant 'c'
         const contribution c = fa_contribution.create ( &amp;
            identifier = 123 &amp;
            first_name = fa_user_name.create ( "Albert"~ ) &amp;
            last_name = fa_user_name.create ( "Newton"~ ) &amp;
            random_number = fa_random_1_15.create ( 5~ ) &amp;
            date_time = fa_local_date_time.create ( "2011-08-27 16:16:30"~ ) )
            
         // verify all attributes
         verify c.identifier =v 123
         verify c.first_name.value =v "Albert"~
         verify c.last_name.value =v "Newton"~
         verify c.random_number.value =v 5~
         verify c.date_time.to_string =v "2011-08-27 16:16:30"

         // verify the value returned by the 'to_string' command
         verify c.to_string =v "Albert Newton contributed '5' on 2011-08-27 16:16:30"
      end
   end
</pre><p>To check that everything is still ok, compile and build your project, then execute <code class="code">run_tests</code>.</p><br><p>You can now relax because the result of the above effort is <span class="emphasis"><em>reliable and secure code</em></span>! <code class="code">Contribution</code> objects can now only be created if all data are valid. Malicious data is rejected at runtime and inhibits the creation of objects. And once a valid object is created it remains in a valid state and nothing wrong can happen anymore because it is immutable. Therefore it can also be freely shared without any precautions to be taken, such as synchronization. It is prepared to be fearlessly used in multi-threading and multi-processor environments.</p><p>The increased type safety achieved through the addition of specific types for attributes <code class="code">first_name</code>, <code class="code">last_name</code> and <code class="code">random_number</code> has also a nice side effect. The compiler now protects against bugs related to semantically incompatible assignments. Suppose, for example, that variable <code class="code">age_of_elephant</code> of type <code class="code">positive32</code> exists in a script. Then a stupid assignment like</p><pre class="programlisting">identifier = age_of_elephant</pre><p>in an instruction that creates a <code class="code">contribution</code> object is immediately rejected by the compiler. Although both values are integers, they are semantically incompatible and the Obix compiler is able to detect this.</p><p>Another benefit results from types <code class="code">user_name</code> and <code class="code">random_1_15</code>. Their conditions coded to validate data can be programmatically used to check untrusted data. For example, a <code class="code">first_name</code> value coming from an external source can be checked with the following expression:</p><pre class="programlisting">const attribute_check_error input_error = ty_user_name.value.check ( first_name_entered_in_web_page )
if input_error #r void then
   // ...
end if</pre><p>Server side code of a web application can use this technique to check data received in a HTTP request, without the need to duplicate the data validation code. We will use this technique in a later chapter</p><p>Finally it is interesting to note that you can add specific features (behavior) to types defined in the above way. Suppose, for example, you create a type <a href="http://en.wikipedia.org/wiki/International_Standard_Book_Number" target="_top"><code class="code">ISBN</code></a> (which is a string limited by a regular expression) in a bookstore application. You could then add command <code class="code">get_publisher_code</code> to type <code class="code">ISBN</code> in order to extract the publisher code of a book.</p><br><p>One last point we didn't consider yet is the requirement for unique, autoincremented values for attribute <code class="code">identifier</code>. We will take care about that later.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="t2_advantages.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><td width="20%" align="center"><a accesskey="u" href="random_arcs_application.html"><img src="images/up.png" alt="Go up one level" title="Go up one level"></a></td><td width="40%" align="right"> <a accesskey="n" href="t2_object_conversion.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr><tr><td width="40%" align="left" valign="top">Advantages (so far) </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Table of contents" title="Table of contents"></a></td><td width="40%" align="right" valign="top"> Step 5: Object conversions and error handling</td></tr></table></div></body></html>
