<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Why Obix?</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><meta name="description" content="This article explains why the Obix programming language has been created."><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="obix_articles.html" title="Obix articles"><link rel="prev" href="obix_articles.html" title="Obix articles"><link rel="next" href="reliability_features.html" title="Obix's 24 Fail fast! concepts for more reliable software."><script type="text/javascript">
        
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-22290805-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Why Obix?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="obix_articles.html">Prev</a> </td><th width="60%" align="center">Obix articles</th><td width="20%" align="right"> <a accesskey="n" href="reliability_features.html">Next</a></td></tr></table><hr></div><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="why_obix"></a>Why Obix?</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Christian</span> <span class="surname">Neumanns</span></h3></div></div><div><p class="pubdate">March 2011</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This article explains why the Obix programming language has been created.</p></div></div></div><hr></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="why_obix_introduction"></a>Introduction</h2></div></div></div><p>Do you prefer to write code or debug code?</p><p>Suppose your application needs to replace text in a file. Which code would you want to write?</p><div class="orderedlist"><ol type="1"><li><p>code that uses <code class="code">open/close</code> file commands; loops to read from and write to fixed-sized buffers in memory; and <code class="code">try-catch-finally</code> blocks to handle exceptions</p></li><li><p>a single instruction that calls a standard library function which takes care of everything and tells you if the operation succeeded</p></li></ol></div><p>Would you like more simplicity in the software creation and maintenance process?</p><p>If you answer these questions with 'write code', '2', 'yes', then you are not alone.</p><p>Practice shows that:</p><div class="itemizedlist"><ul type="disc"><li>Most programs contain <span class="emphasis"><em>many</em></span> bugs and require <span class="emphasis"><em>a lot of debugging</em></span>.</li><li>Developing professional, production-ready software takes a lot of time.</li><li>Writing good code is not easy and requires years of experience.</li></ul></div><p>These are 3 major problems persisting since decades in the software development industry, and they often lead to high development costs.</p><p>But these are also precisely the 3 problems that Obix tries to address - with highest priority. Obix has been specifically designed to:
    </p><div class="itemizedlist"><ul type="disc"><li>produce more reliable software (less bugs)</li><li>increase developer productivity</li><li>simplify the software development process</li></ul></div><p>
  </p><p>The following chapters explain <span class="emphasis"><em>how</em></span> this is done.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reliability"></a>1. More reliability</h2></div></div></div><p>Two undisputable facts subsist in the world of software development:</p><div class="orderedlist"><ol type="1"><li><p>It is very hard to create error-free software; in most cases this is even impossible.</p></li><li><p>The costs generated through errors in software can be huge and the costs often increase dramatically when the errors are detected late in the process of developing-testing-using the software application.</p></li></ol></div><p>Although every programmer probably agrees that too many errors remain in the large majority of software delivered to customers, and that it takes a lot of time, discipline and experience to find and repair those errors, most people are surprised when they hear the 'real numbers' provided by several prominent studies that have been done to prove and quantify the above facts. The highly praised book <em class="citetitle">Code complete, second edition, 2004</em> (ISBN 0-7356-1967-0), written by Steve McConnell contains the following interesting conclusions, which are the results of studies done by companies such as IBM, NASA, etc.</p><div class="itemizedlist"><ul type="disc"><li><p>concerning the number of errors:</p><div class="itemizedlist"><ul type="circle"><li><p>[<span class="citation">Industry average experience is about 1 - 25 errors per 1000 lines of code for <span class="emphasis"><em>delivered</em></span> software</span>] (middle of page 521)</p><p>This means that a mid-size application consisting of 50000 instructions contains not less than 50 to 1250 errors when the software is delivered to the customer(s)! And if it contains 'only' 50 errors it is nevertheless considered to be of 'high reliability', because there is only 1 error in 1000 lines of code.</p></li></ul></div></li><li><p>concerning the costs generated by these errors:</p><div class="itemizedlist"><ul type="circle"><li><p>[<span class="citation">Researchers at HP, IBM, Hughes Aircraft, TRW, and other organizations have found that purging an error by the beginning of construction allows rework to be done 10 to 100 times less expensively than when it's done in the last part of the process, during system test or after release</span>] (top of page 29)</p></li><li><p>[<span class="citation">... software defect removal is actually the most expensive and time-consuming form of work for software</span>] (study at IBM, bottom of page 474)</p></li></ul></div></li></ul></div><p>A famous example of how dramatic the consequences of a bug can be is the Ariane 5 launcher that crashed on June 4, 1996. This crash was due to an arithmetic overflow error at runtime, when a 64 bit floating-point number was converted to a 16 bit signed integer. The (uninsured!) cost was estimated to be 500.000.000 USD!</p><p>A more frequent example would be an error detected in an ERP application after the software has been delivered to hundreds or thousands of customers. Although it might only take a few minutes for the programmer to fix the bug in the source code, the total costs can easily be orders of magnitude higher, because of the need for redeployment and retesting, the need for informing and updating all customers, perhaps the need for correcting wrong results stored in databases, and so on. To this we must add the customers' loss of time, frustration and decrease of trust in the software and the software provider.</p><p>The exponential increase of costs for program errors is schematically shown in the following figure:</p><div class="figure"><a name="costs_of_bugs"></a><p class="title"><b>Figure 1. Costs of bugs</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="costs_time_small.jpg" align="middle" alt="Costs of bugs"></div></div></div><br class="figure-break"><p>Let's do a simple calculation: According to the above facts, an error that costs 7$ when it is detected at compile-time might cost 700$ when it is detected at production-time. If the delivered software contained 100 such errors (most software contain more errors) then the total costs to repair the defects would be 70.000$, instead of only 700$ if they were detected at compile-time. Obviously, such a big difference can determine the success or failure of the project.</p><p>This is of course just a theoretical and oversimplified example. Real costs depend on many factors and can vary largely. But the fact that the cumulative costs of program errors can end up in huge amounts remains true in any case. Detecting errors early can even save lives! Just think about the dramatic consequences a single undetected error could have in a medical application or a national defense application.</p><p>The lesson is clear and leads to the following very important <span class="emphasis"><em>Fail fast!</em></span> rule:</p><p><span class="emphasis"><em>To increase the reliability and maintainability, and reduce costs, software errors must be detected and repaired as early as possible. Errors should preferably be automatically detected at compile-time, or else as early as possible at run-time.</em></span></p><p>The <span class="emphasis"><em>Fail fast!</em></span> rule in software development is very similar to a well known rule in medicine: <span class="emphasis"><em>Prevention is better than cure!</em></span> It is always better and cheaper to prevent or cure early than trying to cure lately, and sometimes a life can be saved.</p><p>Experience proves that the costs of software developments can be reduced considerably if we apply the <span class="emphasis"><em>Fail fast!</em></span> rule.</p><p>Experience also shows that the benefits of bug-reducing features grow exponentially with 
      </p><div class="itemizedlist"><ul type="disc"><li>the size of the application</li><li>the number of programmers involved in the project, as well as the number of programmers who are added or replaced during the project</li><li>the number of changes and extensions during the application's lifecycle</li><li>the number of people using the software</li></ul></div><p>
    </p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fail_fast_concepts"></a><span class="emphasis"><em>Fail fast!</em></span> concepts built into Obix</h2></div></div></div><p>Although no program language can of course prevent programmers from writing bad or erroneous programs, the goal pursued with Obix is to provide a language with facilities that reduce the number of program errors (bugs). As a consequence, Obix <span class="emphasis"><em>helps</em></span> programmers to write more reliable and maintainable code in less time.</p><p>This goal is achieved through a unique combination of proven and innovative concepts which all support the <span class="emphasis"><em>Fail fast!</em></span> rule. Moreover, error-prone programming techniques, such as automatic type conversions, are prevented whenever possible.</p><p>Besides being a compiled, statically typed language, the most important error-preventing concepts built into Obix are:</p><div class="itemizedlist"><ul type="disc"><li>Unit testing</li><li>Contract programming (Design by Contract)</li><li>Feature redefinition in child types</li><li>Generic types (without type erasure at runtime)</li><li>Objects are immutable by default</li><li>Void (null) values are not allowed by default</li></ul></div><p>The full list of over 20 <span class="emphasis"><em>Fail fast!</em></span> concepts integrated in Obix and examples of <span class="emphasis"><em>why</em></span> and <span class="emphasis"><em>how</em></span> they reduce the number of bugs can be found in <a href="reliability_features.html" title="Obix's 24 Fail fast! concepts for more reliable software.">Obix's 24 <span class="emphasis"><em>Fail fast!</em></span> concepts for more reliable software.</a>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fail_fast_advantages"></a>Advantages of the <span class="emphasis"><em>Fail fast!</em></span> rule applied in Obix</h2></div></div></div><p>If the support for less bugs is not embedded in the language, then much more time, discipline and experience is required from the programmers. This distracts from the main task of solving a business problem.</p><p>From the outset Obix has been designed with these concepts kept in mind, in order to immediately integrate them in the language. This approach allows a better implementation than in the case of merely adding these features later to a language, or offering them as an optional, maybe third-party extension. First, the language doesn't suffer from restrictions or exceptional cases which are sometimes inevitable or necessary because of the need for backward compatibility. Secondly, they seamlessly evolve with new versions of the language, because they are part of the language. There are no version conflicts. Thirdly, they are easier to understand and use and no special syntax constructs have to be invented. Finally, the application doesn't depend on optional extensions to the language. As a result, programmers are much more motivated (or compelled) to use them, which leads to better and easier to maintain software.</p><p>Designed to work seamlessly together, the unique combination and interaction of these <span class="emphasis"><em>Fail fast!</em></span> concepts lead to more robust code and less development costs. In this context, it is again interesting to quote the book <em class="citetitle">Code complete</em>:</p><div class="itemizedlist"><ul type="disc"><li><p>[<span class="citation">... if project developers are striving for a higher defect-detection rate, they need to use a combination of techniques</span>] (last paragraph on page 470)</p></li></ul></div><p>Besides being available to write new programs, all <span class="emphasis"><em>Fail fast!</em></span> concepts are also systematically applied in Obix's standard libraries. Again, the goal is to help detecting bugs earlier. For example, contract programming is applied as follows in the standard libraries: If a script calls a <code class="code">string</code> command that extracts a substring from position <code class="code">from</code> to position <code class="code">to</code>, then both input arguments <code class="code">from</code> and <code class="code">to</code> cannot be void (null), and their values must be less or equal to the length of the string. Moreover, <code class="code">to</code> must be equal to or greater than <code class="code">from</code>. Furthermore, the result returned by the command cannot be void, and the length of the substring returned is guaranteed to be equal to <code class="code">to - from + 1</code>. A runtime error occurs immediately if any condition is violated.</p><p>Moreover, the software libraries are designed in a way that more errors can be detected at compile-time, or early at runtime. For example, instead of defining a single <code class="code">file</code> type that is used for absolute and relative files, as well as for absolute and relative directories, Obix provides 4 distinct types with some common functionalities, and some type-specific functionalities. Thus, writing code that tries to delete a relative file, or code that tries to store a string into a directory instead of a file, result in compile-time errors.</p><p>Because Obix is statically typed, and also because it supports generic types with no type erasure at runtime, it will be possible to write static analysis tools in the future, or to integrate static analysis in the compiler, so that even more errors can be found automatically. Tools like <code class="code">FindBugs</code> (<a href="http://findbugs.sourceforge.net/" target="_top">http://findbugs.sourceforge.net/</a>) prove that it is possible to find bugs with static analysis.</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="productivity"></a>2. More productivity</h2></div></div></div><p>It goes without saying that more productivity is another important goal pursued in software development projects.</p><p>Obviously, the above mentioned concepts for increased reliability and maintainability also increase productivity, because less bugs leads to less time spent to find and repair bugs.</p><p>More productivity is also achieved by making recurring tasks as easy as possible. Here are some examples:</p><div class="itemizedlist"><ul type="disc"><li><p>Besides applying the <span class="emphasis"><em>Fail fast!</em></span> concepts in Obix's libraries, these libraries also aim to provide single commands to execute common tasks that would otherwise require to write a whole script. For example, replacing a string in a text file with another string can be done with a single command (that supports regular expressions), instead of having to read from and write to the file in a loop using buffers, and embed the operation in a <code class="code">try-catch-finally</code> block to properly close the file and handle resource errors. Such high-level commands not only increase productivity, they also help to reduce the number of bugs, because writing a single command is much less error-prone than writing a script with loops and <code class="code">try-catch-finally</code> blocks.</p></li><li><p>It is easy to create the different kinds of applications required in practice, ranging from quickly executing a single instruction, up to developing a complex web application. For example, if you just want to write and execute a small script to test some code or to create a small utility, you don't need to create and maintain a project. You can simply put the source code into a text file located anywhere on the disk or the network, and then execute it. For more information and examples of different kinds of applications (e.g. command-line utilities, terminal input/ouput applications, desktop applications or web applications) please refer to <a href="tutorial_part_1.html" title="Part I. How to create and execute code">Part I, &#8220;How to create and execute code&#8221;</a> in the tutorial.</p></li><li><p>The Obix compiler automatically takes care of some frequent tasks that have to be done manually in other programming languages and thus lead to so-called boilerplate code. For example:</p><div class="itemizedlist"><ul type="circle"><li><p>You don't have to add and maintain <code class="code">package</code> and <code class="code">import</code> statements in the head of source code files. The compiler creates them automatically, based on the location of the source code files in the directory structure.</p></li><li><p>You don't have to write 'getters' and 'setters', except when special behavior is required.</p></li><li><p>Simple object constructors that take one input argument for each attribute of an object are created by the compiler, if desired.</p><p>For example, a Java constructor like this:</p><pre class="programlisting">public Customer ( int identifier, String name, String address, String city ) {
   this.identifier = identifier;
   this.name = name;
   this.address = address;
   this.city = city;
}</pre><p>is reduced to the following single instruction in Obix:</p><pre class="programlisting">creator create kind:in_all end</pre></li></ul></div></li><li><p>Java source code can easily be embedded in Obix source code. This means that you can use the vast number of existing Java libraries in your Obix applications. The inverse is true too. Obix code can be called from within Java code, and data can easily be exchanged between Obix and Java. For more information, please refer to <a href="embedded_java.html" title="Chapter 10. Embedded Java source code">Chapter 10, <i>Embedded Java source code</i></a>.</p></li><li><p>Applications can be developed on Windows or Linux systems, and then be deployed on Windows and/or Linux systems. The libraries take care of the differences between the Unix- and Windows-world, such as different line feed characters and different file path separators.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>At the time of writing, a web framework for Obix is under construction. This framework aims to considerably simplify and speed up the development of professional websites with a modern user interface. The main goals are:</p><div class="itemizedlist"><ul type="disc"><li>automatic creation of dynamic web sites to interact with Obix objects (no need to write GUI code; ideal for prototyping).</li><li>the framework's default web sites can be customized by writing web site code in Java or Obix (no need to write HTML, Javascript and CSS code, except in case of very specific requirements).</li><li>complete separation of business code and UI code.</li><li>rich user interfaces provided by default (e.g. sorting, filtering, sizing and paging of tables).</li></ul></div><p>The availability of this framework will be announced on www.obix.lu.</p></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="simplicity"></a>3. More simplicity</h2></div></div></div><p>Besides increased reliability and productivity, a programming language should also be easy to learn and use.</p><p>Nobody said it better than Albert Einstein: <span class="emphasis"><em>Everything should be as simple as possible, but not simpler.</em></span></p><p>Productivity and simplicity go hand in hand. If a programming language increases productivity, then it is generally also simpler to use. Therefore, all points mentioned in the previous chapter about productivity also lead to more simplicity. Moreover, the following design choices add to simplicity:</p><div class="itemizedlist"><ul type="disc"><li><p>Important object oriented concepts are automatically enforced through the language itself, so that the programmer can't violate them. For example, the hiding of implementation details is automatically enforced through the concept of types (i.e. the interface) and factories (i.e. the implementation) (see <a href="RSEs.html#type" title="Type">the section called &#8220;Type&#8221;</a> and <a href="factory.html" title="Factory">the section called &#8220;Factory&#8221;</a>). The types define <span class="emphasis"><em>what</em></span> you can do with an object. The factories define <span class="emphasis"><em>how</em></span> this is realized.</p></li><li><p>Obix favors strict default values. This helps programmers to write better code without extra efforts. For example, objects are immutable by default, void values are not allowed by default, and code is statically typed by default.</p><p>Default values for input arguments in the standard libraries are also defined in a strict, non-error-prone way.</p></li><li><p>The source code syntax has intentionally been designed to be easy to understand. This implies that we have to type a little bit more sometimes, but the reasons for favoring read-ability over write-ability are:
        </p><div class="itemizedlist"><ul type="circle"><li>Programmers spend more time reading code and trying to understand code, than writing code. It is generally assumed that about 70% of programmers' time is spent to maintain code.</li><li>Quickly understanding code is important when we have to read code written by somebody else (or written by ourselves 2 years ago).</li><li>Less experienced or occasional programmers shouldn't struggle with cryptic or ambiguous syntax constructs.</li><li>Obix supports source code templates. Besides helping to avoid code duplication, templates also reduce the amount of code that has to be typed and maintained.</li></ul></div><p>
      </p></li><li><p>As stated previously, confusing and error-prone programming techniques, such as automatic type casts, are prevented.</p></li><li><p>Because everything is an object in Obix, you don't have to deal with different and sometimes surprising or restrictive behaviors of primitive data types and arrays co-existing with 'real' objects.</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conclusion"></a>Conclusion</h2></div></div></div><div class="figure"><a name="why_obix_figure"></a><p class="title"><b>Figure 2. Why Obix?</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="why_obix_small.jpg" align="middle" alt="Why Obix?"></div></div></div><br class="figure-break"></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="obix_articles.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="obix_articles.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="reliability_features.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Obix articles </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Obix's 24 <span class="emphasis"><em>Fail fast!</em></span> concepts for more reliable software.</td></tr></table></div></body></html>
