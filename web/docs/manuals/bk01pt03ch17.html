<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 17. Contract programming</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="bk01pt03.html" title="Part III. Advanced concepts"><link rel="prev" href="bk01pt03ch16.html" title="Chapter 16. Static typing"><link rel="next" href="bk01pt03ch18.html" title="Chapter 18. Feature redefinition"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 17. Contract programming</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01pt03ch16.html">Prev</a> </td><th width="60%" align="center">Part III. Advanced concepts</th><td width="20%" align="right"> <a accesskey="n" href="bk01pt03ch18.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="contract_programming"></a>Chapter 17. Contract programming</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_description"></a>Description</h2></div></div></div><p><em class="firstterm">Contract programming</em>, also known as <em class="firstterm">Design By Contract (DBC)</em> (TM) is used to ensure that specific conditions, which are defined in the source code, are always fulfilled at runtime. Whenever a given condition is not fulfilled then a program error is raised immediately.</p><p>There are several kinds of conditions that can be specified. They are used to:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>protect an attribute, input argument or output argument against invalid values</em></span></p><p>While <span class="emphasis"><em>static typing</em></span> ensures that only an object of a defined type (or any compatible type) can be assigned to an object reference, <span class="emphasis"><em>contract programming</em></span> goes a step further by limiting the set of allowed values that can be assigned. For example, <span class="emphasis"><em>static typing</em></span> ensures that only a <code class="code">positive32</code> object can be assigned to an attribute of type <code class="code">positive32</code>, and <span class="emphasis"><em>contract programming</em></span> can then be used to restrict the allowed values to, let's say, values between 10 and 20.</p></li><li><p><span class="emphasis"><em>ensure that the state (i.e. the set of all attribute values) of an object or service fulfills one or more conditions</em></span></p><p>Suppose type <code class="code">address</code> has attributes <code class="code">postal_code</code>, <code class="code">city</code>, and <code class="code">country</code>. Contract programming could then be used to ensure that the <code class="code">city</code> actually exists in the <code class="code">country</code>, and that the <code class="code">postal_code</code> exists for that <code class="code">city</code>.</p></li><li><p><span class="emphasis"><em>ensure that one or more conditions are fulfilled before executing a command</em></span></p><p>An example would be a file that must exist before executing a command.</p></li><li><p><span class="emphasis"><em>ensure that one or more conditions are fulfilled after executing a command</em></span></p><p>Example: a network connection must be available after executing a command that establishes this connection, or else an error must be returned.</p></li><li><p><span class="emphasis"><em>ensure that a specific condition is fulfilled somewhere in a script</em></span></p><p>This can be used to ensure a loop invariant, ensure that a variable is not void at some point of execution, check that the sum of two integer constants is less than 100, etc.</p></li></ul></div><p>The next section describes the rules for using <span class="emphasis"><em>Contract programming</em></span> in Obix.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_rules"></a>Rules</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>There are two ways to define contract programming conditions:</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>Simple conditions are defined through an expression of type <code class="code">yes_no</code>. If the expression evaluates to <code class="code">yes</code>, the condition is fulfilled. If it evaluates to <code class="code">no</code> or <code class="code">void</code> it is not fulfilled.</p></li><li><p>More complex and multiple conditions are defined through a check script that returns <code class="code">void</code> if all conditions are fulfilled. As soon as a condition is unfulfilled, the script returns an error object describing the problem. A condition in the script is specified with the <code class="code">check</code> instruction (see <a href="bk01pt02ch08s06.html#check_instruction" title="check instruction">the section called &#8220;<code class="code">check</code> instruction&#8221;</a>). The <code class="code">check</code> instruction evaluates an expression of type <code class="code">yes_no</code>. If the expression evaluates to <code class="code">yes</code>, the condition is fulfilled. If it evaluates to <code class="code">no</code> or <code class="code">void</code> it is not fulfilled, and the script immediately returns an error object.</p></li></ul></div><p>Please refer to the links in the following table for details about how to code the different kinds of conditions:</p><div class="table"><a name="contract_programming_links"></a><p class="title"><b>Table 17.1. Contract programming links</b></p><div class="table-contents"><table summary="Contract programming links" cellspacing="0" cellpadding="5" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Relates to</th><th>Kind of condition</th><th>How to code</th><th>Definition of check script</th></tr></thead><tbody><tr><td rowspan="2" valign="middle">Attributes</td><td>check the value of a single attribute</td><td><a href="bk01pt02ch06.html#attribute_check_property" title="Attribute property check">the section called &#8220;Attribute property <code class="code">check</code>&#8221;</a></td><td><a href="bk01pt02ch07s05s02.html" title="Attribute check script">the section called &#8220;Attribute <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check the state of an object or service (multiple attributes)</td><td><a href="bk01pt02ch06.html#attribute_list_check_property" title="Property attribute_check">the section called &#8220;Property <code class="code">attribute_check</code>&#8221;</a></td><td><a href="bk01pt02ch07s05.html#attribute_list_check_script" title="attribute_check script">the section called &#8220;<code class="code">attribute_check</code> script&#8221;</a></td></tr><tr><td rowspan="4" valign="middle">Commands</td><td>check the value of a single input argument</td><td><a href="bk01pt02ch06s02.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></td><td><a href="bk01pt02ch07s05s04.html" title="Input argument check script">the section called &#8220;Input argument <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check the value of a single output argument</td><td><a href="bk01pt02ch06s02.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></td><td><a href="bk01pt02ch07s05s06.html" title="Output argument check script">the section called &#8220;Output argument <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check input conditions before executing a command</td><td><a href="bk01pt02ch06s02.html#logger_service_in_check" title="Example 6.7. in_check (using an expression)">Example 6.7, &#8220;<code class="code">in_check</code> (using an expression)&#8221;</a></td><td><a href="bk01pt02ch07s05s03.html" title="Command in_check script">the section called &#8220;Command <code class="code">in_check</code> script&#8221;</a></td></tr><tr><td>check output conditions after executing a command</td><td><a href="bk01pt02ch06s02.html#logger_service_output_example" title="Example 6.8. Multiple output arguments">Example 6.8, &#8220;Multiple output arguments&#8221;</a></td><td><a href="bk01pt02ch07s05s05.html" title="Command out_check script">the section called &#8220;Command <code class="code">out_check</code> script&#8221;</a></td></tr><tr><td>Scripts</td><td>ensure a condition is fulfilled in a script</td><td><a href="bk01pt02ch08s06s02.html" title="check script instruction">the section called &#8220;<code class="code">check script</code> instruction&#8221;</a></td><td>not applicable</td></tr></tbody></table></div></div><br class="table-break"></li><li><p><span class="emphasis"><em>Contract programming conditions defined in a type are implicitly inherited in every child type</em></span></p><p>This rule is a logical consequence of the <a href="bk01pt03ch15.html#type_compatibility_rule">type compatibility rule</a>. Because a child type is always compatible to all its parent types, all contract programming conditions defined in a type must also be enforced in any child type.</p><p>For example, if a type's command returns an integer value that is guaranteed to be greater than 10, a child type must also ensure this condition. If it was allowed to return the value 7, for example, type compatibility would be violated.</p></li><li><p><span class="emphasis"><em>Contract programming conditions defined in a type can be loosen or strengthened in a child type, as long as type compatibility is preserved.</em></span></p><p>Please refer to <a href="bk01pt03ch18.html" title="Chapter 18. Feature redefinition">Chapter 18, <i>Feature redefinition</i></a> for more information.</p></li><li><p><span class="emphasis"><em>Contract programming conditions defined in a type are automatically enforced in every factory that implements this type.</em></span></p><p>There is no need to explicitly (re)check conditions in factories. For example, if a type specifies that a command's input argument of type <code class="code">string</code> must contain at least 10 characters, then the factory can rely on this condition and doesn't need to add code such as <code class="code">if input_value.item_count &lt; 10 then ...</code>.</p></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_tips"></a>Tips</h2></div></div></div><p>Here are some tips to consider when using contract programming.</p><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>To ensure that an object reference cannot be <code class="code">void</code> at runtime, property <code class="code">voidable</code> should be used, rather than contract programming.</em></span></p><p>Although contract programming could be used to check for <code class="code">void</code>, using property <code class="code">voidable</code> is easier to use, and allows the compiler to make some optimizations. However, if the check for <code class="code">void</code> depends on circumstances at runtime, then  contract programming must be used (e.g. an attribute's voidability depends on a parameter stored in an XML configuration file)</p><p>Please refer to the following links for more information:</p><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt02ch06.html#attribute_voidable_property" title="Attribute property voidable">the section called &#8220;Attribute property <code class="code">voidable</code>&#8221;</a> (attribute)</li><li><a href="bk01pt02ch06s02.html#argument_voidable_property" title="Argument property voidable">the section called &#8220;Argument property <code class="code">voidable</code>&#8221;</a> (input/output argument)</li><li><a href="bk01pt03ch12.html" title="Chapter 12. Void values">Chapter 12, <i>Void values</i></a></li></ul></div><p></p></li><li><p><span class="emphasis"><em>If the same condition is defined for more than one object reference (attribute, input argument or output argument), then consider defining a new type that contains this condition and use this type for each object reference.</em></span></p><p>Suppose types <code class="code">meeting</code> and <code class="code">asset</code> both have attribute <code class="code">remark</code> which is a <code class="code">string</code> limited to 1024 characters. The types could be defined as follows:</p><pre class="programlisting">type meeting 

   // some attributes not shown here

   attribute remark type:string check: i_remark.item_count &lt;= 1024 end

end</pre><pre class="programlisting">type asset 

   // some attributes not shown here

   attribute remark type:string check: i_remark.item_count &lt;= 1024 end

end</pre><p>However, a much better solution is to define a new type <code class="code">remark</code> as:</p><pre class="programlisting">type remark

   inherit string
      attribute value and_check: i_value.item_count &lt;= 1024 end
   end

end</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This code uses <span class="emphasis"><em>type inheritance</em></span> and <span class="emphasis"><em>feature redefinition</em></span>. Please refer to <a href="bk01pt03ch15.html" title="Chapter 15. Type inheritance">Chapter 15, <i>Type inheritance</i></a> and <a href="bk01pt03ch18.html" title="Chapter 18. Feature redefinition">Chapter 18, <i>Feature redefinition</i></a> for more information about these techniques.</p></td></tr></table></div><p>Now types <code class="code">meeting</code> and <code class="code">asset</code> can both use type <code class="code">remark</code> like this:</p><pre class="programlisting">type meeting_2

   // some attributes not shown here

   attribute remark type:remark end

end</pre><pre class="programlisting">type asset_2

   // some attributes not shown here

   attribute remark type:remark end

end</pre><p>Besides the obvious advantage that the code gets easier to write, the design has been improved for the following reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>Code duplication, one of the biggest enemies of software maintainability, has been eliminated.</p><p>If somewhere in the future, <code class="code">remark</code>s will be limited to 2048, instead of 1024 characters, there is only one place to change in the code (i.e. type <code class="code">remark</code>). This saves time and eliminates the risk of forgetting to make the same change in other types that have a <code class="code">remark</code> attribute.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Source code duplication could also be eliminated by using <span class="emphasis"><em>source code templates</em></span> (see <a href="bk01pt03ch20.html" title="Chapter 20. Source code templates">Chapter 20, <i>Source code templates</i></a>), but this method lacks the advantage of type safety (see below); therefore this solution is not shown here.</p></td></tr></table></div><p></p></li><li><p>The same type <code class="code">remark</code> can now easily be used in other types with a <code class="code">remark</code> attribute.</p></li><li><p>Type safety is increased, because a <code class="code">remark</code> is now semantically different from a standard <code class="code">string</code>.</p><p>For example, an error like assigning the name of an elephant (defined as <code class="code">string</code>) to the <code class="code">remark</code> attribute of a <code class="code">meeting</code> object would be detected by the compiler.</p></li></ul></div></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_rationale"></a>Rationale</h2></div></div></div><p>Contract programming is undoubtedly one of the most effective means to support the <span class="emphasis"><em>fail fast</em></span> principle. It helps to detect programming errors in an early stage and therefore greatly contributes to more reliable and maintainable code.</p><p>This is due to the fact that in a typical application there are hundreds or thousands of contract programming conditions scattered throughout the code. These conditions are verified continuously at runtime, so that any violation immediately generates a runtime error.</p><p>One of the most strategically important conditions are the command input conditions, because these are the conditions that risk to be violated mostly. Why? Because a client script that calls a supplier script is often written by different programmers who might make different assumptions, for example in case of using Obix's standard library, or a third party library. Or, the same programmer might have forgotten the input conditions of a supplier script he wrote some time ago. In such cases the risk of bad input data transmitted from the client to the supplier script is higher, and contract programming effectively helps to detect these problems quickly.</p><p>Another advantage is that contract programming conditions in the source code greatly document program interfaces in an infallible way. Without contract programming, a condition expressed as a simple comment such as <code class="code">value should not contain more than 1024 characters</code> cannot be used by the compiler to actually check the condition at runtime. Hence the comment might be in discordance with the code. Moreover it can become outdated if the code is changed without changing the code's comment.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_examples"></a>Examples</h2></div></div></div><p>Examples of contract programming can be found in the links listed in the following section.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_see_also"></a>See also</h2></div></div></div><p>attributes:</p><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt02ch06.html#attribute_check_property" title="Attribute property check">the section called &#8220;Attribute property <code class="code">check</code>&#8221;</a></li><li><a href="bk01pt02ch06.html#attribute_list_check_property" title="Property attribute_check">the section called &#8220;Property <code class="code">attribute_check</code>&#8221;</a></li><li><a href="bk01pt02ch07s05s02.html" title="Attribute check script">the section called &#8220;Attribute <code class="code">check</code> script&#8221;</a></li><li><a href="bk01pt02ch07s05.html#attribute_list_check_script" title="attribute_check script">the section called &#8220;<code class="code">attribute_check</code> script&#8221;</a></li></ul></div><p>input/output arguments:</p><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt02ch06s02.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></li><li><a href="bk01pt02ch07s05s04.html" title="Input argument check script">the section called &#8220;Input argument <code class="code">check</code> script&#8221;</a></li><li><a href="bk01pt02ch07s05s03.html" title="Command in_check script">the section called &#8220;Command <code class="code">in_check</code> script&#8221;</a></li><li><a href="bk01pt02ch07s05s06.html" title="Output argument check script">the section called &#8220;Output argument <code class="code">check</code> script&#8221;</a></li><li><a href="bk01pt02ch07s05s05.html" title="Command out_check script">the section called &#8220;Command <code class="code">out_check</code> script&#8221;</a></li></ul></div><p>related topics:</p><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt03ch12.html" title="Chapter 12. Void values">Chapter 12, <i>Void values</i></a></li><li><a href="bk01pt03ch18.html" title="Chapter 18. Feature redefinition">Chapter 18, <i>Feature redefinition</i></a></li><li><a href="bk01pt03ch13.html" title="Chapter 13. Runtime error handling">Chapter 13, <i>Runtime error handling</i></a></li><li><a href="bk01pt03ch16.html" title="Chapter 16. Static typing">Chapter 16, <i>Static typing</i></a></li><li><a href="bk01pt03ch15.html" title="Chapter 15. Type inheritance">Chapter 15, <i>Type inheritance</i></a></li></ul></div><p>instructions:</p><div class="itemizedlist"><ul type="disc"><li><a href="bk01pt02ch08s06.html#check_instruction" title="check instruction">the section called &#8220;<code class="code">check</code> instruction&#8221;</a></li><li><a href="bk01pt02ch08s06s02.html" title="check script instruction">the section called &#8220;<code class="code">check script</code> instruction&#8221;</a></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01pt03ch16.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="bk01pt03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bk01pt03ch18.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 16. Static typing </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 18. Feature redefinition</td></tr></table></div></body></html>
