<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 8. Static typing</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="advanced_concepts.html" title="Part II. Concepts for more reliable code"><link rel="prev" href="object_immutability.html" title="Chapter 7. Object immutability"><link rel="next" href="generic_types.html" title="Chapter 9. Generic types"><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29648172-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 8. Static typing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="object_immutability.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><th width="60%" align="center">Part II. Concepts for more reliable code</th><td width="20%" align="right"> <a accesskey="n" href="generic_types.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="static_typing"></a>Chapter 8. Static typing</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_typing_description"></a>Description</h2></div></div></div><p>Obix is a statically typed language.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_typing_rules"></a>Rules</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>The type of object that can be assigned to an object reference (attribute, input argument, output argument, script constant or script variable) must always be explicitly specified in the source code.</em></span></p><p>The following example shows how the type of object references is explicitly declared:</p><pre class="programlisting">service static_typing_examples

   attribute foo type:string default:"foo" end // type of attribute is 'string'

   command example_1
      in foo type:character end        // type of input argument is 'character'
      out bar type:positive32 end      // type of output argument is 'positive32'

      script
         const zero_positive32 tar = 0 // type of constant is 'zero_positive32'
         var yes_no zar = yes          // type of variable is 'yes_no'
         // ...
      end
   end

end service</pre></li><li><p><span class="emphasis"><em>If an object reference <code class="code">R</code> is of type <code class="code">T</code> then only objects of type <code class="code">T</code> or child types of type <code class="code">T</code> (i.e. types that are compatible to type <code class="code">T</code>) can be assigned to <code class="code">R</code>.</em></span></p><p>This rule is a repetition of the <a href="type_inheritance.html#type_compatibility_rule">type compatibility rule</a> discussed in <a href="type_inheritance.html" title="Chapter 12. Type inheritance">Chapter 12, <i>Type inheritance</i></a>. Please refer to that section for additional explanations and examples.</p></li><li><p><span class="emphasis"><em>If the type of an object cannot be known at compile-time, then the <code class="code">case type of</code> instruction can be used to check the type at run-time and execute appropriate instructions.</em></span></p><p>Please refer to <a href="case_type_of_instruction.html" title="case type of instruction">the section called &#8220;<code class="code">case type of</code> instruction&#8221;</a> for additional explanations and examples.</p></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_typing_rationale"></a>Rationale</h2></div></div></div><p>Static typing largely contributes to better code, less bugs, and increased maintainability, as explained below.</p><div class="itemizedlist"><ul type="disc"><li><p>Static typing increases source code understandability.</p><p>The obligation to declare the <span class="emphasis"><em>type</em></span> of an object reference makes it often more easy to understand source code, especially source code written by somebody else.</p><p>Suppose, for example, that a script declares a variable to store the quality of products.</p><p>If Obix was a dynamically typed language, the variable declaration could look like this:</p><pre class="programlisting">var quality_level</pre><p>We can deduce from the above instruction that the level of quality is stored in variable <code class="code">quality_level</code>, but we can't see <span class="emphasis"><em>how</em></span> the information is stored.</p><p>On the other hand the statically typed instruction:</p><pre class="programlisting">var zero_positive32 quality_level</pre><p>tells us immediately that the level of quality is stored as a positive integer value that can be 0.</p></li><li><p>Static typing supports the <span class="emphasis"><em>"fail fast!"</em></span> principle, and therefore increases reliability and maintainability.</p><p>Static typing enables the compiler to reliably detect errors that would otherwise only produce runtime errors or, even worse, produce wrong results that are sometimes only detected late after the whole application is already in production.</p><p>It is best to illustrate this with an example.</p><p>Let's continue with our previous example of software that handles the quality of products. Suppose we want to express the quality as an integer value ranging from 0 (very bad) to 9 (very good) and store the qualities of several products in a list.</p><p>As we have seen already, if Obix was a dynamically typed language, a variable declaration holding the quality of a product would look like this:</p><pre class="programlisting">var quality_level</pre><p>Let's see what could happen now subsequently, still supposing Obix was a dynamically typed language.</p><p>If a product has a quality level of 5, we could write:</p><pre class="programlisting">quality_level = 5</pre><p>BUT: We could also write:</p><pre class="programlisting">quality_level = "5"</pre><p>The compiler wouldn't generate an error, although our intention was to store qualities as integers, not as strings. Even worse, no runtime error is generated.</p><p>Nonsense instructions like the following ones would also pass without producing a compile- or run-time error:</p><pre class="programlisting">quality_level = "ok"
quality_level = "I don't know"
quality_level = yes
quality_level = fa_customer.create ( identifier = "123"; name = "Bob" )</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>One might argue that nobody would ever write silly instructions like the above ones. However, we are here just looking at the most simplest instructions that allow us to understand the idea, and thus simplify the exercise. In a real application, the value of <code class="code">quality_level</code> would rather be defined through the execution of another routine (possibly in another library) that returns a value. Obviously, this makes it more difficult to immediately grasp the error with a quick look at the source code. Experience shows that silly programming errors of the above kind are much more frequent than one would imagine, especially in big applications written by many programmers.</p></td></tr></table></div><p>Let's now store some values in a list. The code to create a list and store a value would be:</p><pre class="programlisting">var list = fa_list.co_create
list.append ( quality_level )</pre><p>Once again we have a problem. Because the type of objects in the list is not specified, any value can be stored in the list, including all the silly values shown previously. No compiletime or runtime error is generated!</p><p>The consequences can be evil. Suppose, for instance, we want to count how many products have quality level 5. The code is:</p><pre class="programlisting">var count = 0
repeat for each quality in list
   if quality =v 5 then
      count = count + 1
   end if
end repeat</pre><p>How will the application behave when <code class="code">if quality =v 5</code> is executed and the string value <code class="code">"5"</code> is retrieved from the list? It depends on the compiler! The application could generate a runtime error, because "5" cannot be compared to 5. But in a dynamically typed language the application would more probably continue execution and decide that "5" is <span class="emphasis"><em>not</em></span> equal to 5. Or it could silently convert 5 to "5", which means that the values are  <span class="emphasis"><em>equal</em></span>.</p><p>The awful fact that "it depends on the compiler" and that the result of the boolean expression <code class="code">quality =v 5</code> can be a runtime error, or true or false is of course unacceptable. In a well designed language, nothing should ever depend on the internals of the compiler, because it makes the programmer's difficult life even more difficult. Moreover, an application's behavior could change if it is compiled with another compiler that applies different internal rules!</p><p>It is not difficult to find other examples of wrong results. Suppose we want to display the list on screen. But instead of displaying values from 0 to 9, we display values ranging from 1 to 10:</p><pre class="programlisting">repeat for each quality in list
   console.message ( quality + 1 )
end repeat</pre><p>What happens this time if a string value of <code class="code">"5"</code> is in the list? Once again, it depends on the compiler! Most probably, the compiler would silently convert the integer <code class="code">1</code> to string <code class="code">"1"</code>, and the value displayed would be "51", which is the result of concatenating strings "5" and "1"!!!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Although Java is not a dynamically typed language, the above behavior is indeed built into the language. To proof this, it is sufficient to execute the following statements:</p><pre class="programlisting">String quality_level = "5";
System.out.println ( quality_level + 1 );</pre><p>The compiler (Sun's compiler of Java version 6) does not nag and the result displayed is <code class="code">51</code>!</p><p></p></td></tr></table></div><p>The good news is that all these problems can't happen in a statically typed language, because the compiler detects all errors immediately.</p><p>The above code rewritten in real Obix is shown below, and the comments explain how all previously encountered errors are immediately caught at compile-time:</p><pre class="programlisting">service static_typing_examples

   command example_2
      script
         var zero_positive32 quality_level
         quality_level = 5      // ok
         // quality_level = "5" // refused by compiler, because 'quality_level' can only hold 'zero_positive32' objects

         // declare mutable indexed list that contains 'zero_positive32' objects
         var !mutable_indexed_list&lt;zero_positive32&gt; list = !mutable_indexed_list_factory&lt;zero_positive32&gt;.co_create

         list.append ( quality_level ) // ok
         // list.append ( "5" )        // refused by compiler, because list can only contain 'zero_positive32' objects

         var zero_positive32 count = 0
         repeat for each zero_positive32 quality in list
            if quality =v 5 then // ok
            // if "5" =v 5 then  // refused by compiler, because 2 different types cannot be compared without explicit conversion
              count = count + 1
            end if

            system.console.write_line ( (quality + 1).to_string ) // ok, because the result of the addition is explicitly converted
                                                        // into a 'string'. there is no ambiguity.
         // system.console.write_line ( "5" + 1 ) // refused by compiler, because a 'zero_positive32' object cannot be 
                                        // appended to a 'string' object without explicit conversion

         end repeat
      end
   end

end service</pre><p>A last remark remains to be made. We initially specified that the quality level ranges from 0 to 9. However, in the above code we use type <code class="code">zero_positive32</code>, which means that values above 9 would also be accepted. The instruction <code class="code">quality_level = 100</code> wouldn't generate a compile- or run-time error.</p><p>To solve this problem, the best solution is to define a new type <code class="code">product_quality_level</code> as follows:</p><pre class="programlisting">type product_quality_level 

   inherit zero_positive32
      attribute value and_check: i_value &lt;= 9.value end
   end

end</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The above code uses <span class="emphasis"><em>feature redefinition</em></span> which is explained in <a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Chapter 10, <i>Feature redefinition</i></a>. Please refer to that section for further explanations.</p></td></tr></table></div><p>Besides the advantage of range verification (0 to 9), the code now becomes even more robust, because the quality level is now semantically different from a <code class="code">zero_positive32</code> value. Hence, errors like assigning a loop index to a variable holding the quality of a product are now also detected at compile-time, as shown below:</p><pre class="programlisting">service static_typing_examples

   command example_3
      script
         var zero_positive32 loop_index = 5
         var product_quality_level quality_level
         // quality_level = loop_index  // refused by compiler, because types are not compatible
      end
   end

end service</pre></li><li><p>Static typing increases the quality of code in software projects.</p><p>Although static typing is of course not a <span class="emphasis"><em>guarantee</em></span> for better quality of code, it often leads to, or enforces, better quality. Because more errors are detected at compile-time (as seen before), the programmer is forced to correct the real source of those errors immediately. This often discourages and reduces sloppy programming and leads to a better design and typing system.</p><p>Consider, for example, the following situation.</p><p>The above mentioned error <code class="code">quality = "5"</code> (instead of <code class="code">quality = 5</code>) stays undetected and the application goes into production. One day, a customer reports that the result of counting the number of products with quality level 5 is wrong: "The computer displays 570 items instead of 571!".</p><p>The programmer responsible for repairing the bug finds the following code we wrote earlier:</p><pre class="programlisting">var count = 0
repeat for each quality in list
   if quality =v 5 then
      count = count + 1
   end if
end repeat</pre><p>After some time of testing he or she discovers that one item in the customer's list is a string value of "5", instead of an integer value of 5, and that the expression <code class="code">quality =v 5</code> evaluates to false, because the compiler considers that "5" and 5 are unequal.</p><p>The important question is now: What will the programmer do?</p><p>Obviously, the programmer <span class="emphasis"><em>should</em></span> search for the reason of having a string in the list, and then correct the source of the problem.</p><p>However, in practice there is often a difference between what the programmer <span class="emphasis"><em>should do</em></span>, and what he or she <span class="emphasis"><em>actually does</em></span>.</p><p>The big question is now: What will the programmer do?</p><p>In our simplified example, the problem could of course easily be fixed by replacing <code class="code">quality = "5"</code> with <code class="code">quality = 5</code>. But in a real world application, it can get difficult and time-consuming, or even impossible, to find and fix the source of the problem, because the bug might have been created by another programmer, it might exist at several locations spread throughout the source code, or it might exist in a third-party library which is delivered without source code.</p><p>Therefore, the programmer looks for a quick and easy solution. Finally he or she replaces</p><pre class="programlisting">if quality =v 5 then</pre><p>with</p><pre class="programlisting">if quality =v "5" or quality =v 5 then</pre><p>and the problem is solved!</p><p>That's what might actually happen in practice!</p><p>The consequences are dreadful, because the source of the problem has not been removed:</p><div class="itemizedlist"><ul type="circle"><li><p>The quality of code has decreased because the instruction <code class="code">if quality =v "5" or quality =v 5 then</code> is a "hack" and reduces source code understandability, especially for other programmers who are not aware of the problem reported by the customer.</p></li><li><p>Although the customer's particular problem has been solved, there remains the risk of other wrong objects that will appear in the list later on, and cause similar or different problems.</p></li><li><p>The problem of a string in the list might cause other problems not yet detected in other parts of the application.</p></li></ul></div><p>It is easy to see that many other similar problems can appear with dynamic typing, up to the point of jeopardizing a software project, especially in case of a big application that is written by many programmers, used by many users and extended continuously.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Some people claim that dynamically typed languages makes them more productive. But this is only a <span class="emphasis"><em>perceived</em></span> advantage. The programmer <span class="emphasis"><em>feels</em></span> he or she writes more code in less time, because the compiler is less severe and accepts code that wouldn't be accepted in a statically typed language. But at the end this is deceptive, because the errors will only appear later, maybe during the test phase, or after the application is in production. And experience shows that the later a bug or bad design is detected, the more time-consuming, expensive and stressful it will be to correct the error.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Some people claim that static typing is not necessary when a good framework for testing is available, because all errors will then be detected through unit tests. While it is true that all errors <span class="emphasis"><em>could</em></span> be detected with adequate tests, it is also true that it is difficult, and in most cases even impossible, to write perfect unit tests that discover all errors, especially in the case of dynamic typing, because dynamic typing opens the door for more errors for which test cases have to be written. Moreover, writing tests  also requires time and experience. Practice shows that a number of programmers don't write unit tests, even if they have good support for it. And some of them will probably never write unit tests, because they think that other people are responsible for testing their code, or because it requires time, discipline, experience, and sometimes also a good portion of humility.</p><p>Without doubts, unit tests are very useful to detect bugs. However, they are an excellent complement, but not a replacement for static typing and other features, such as genericity, contract programming and feature redefinition. For more information about writing tests in Obix, please refer to <a href="testing.html" title="Chapter 5. Testing">Chapter 5, <i>Testing</i></a></p><p>The excellent book <em class="citetitle">Code complete, second edition</em> (ISBN 0-7356-1967-0), written by Steve McConnell contains interesting conclusions about bugs, which are the results of studies done by IBM, NASA, etc. Besides telling us that [<span class="citation">fixing defects in source code often costs 10 times what it took to develop the whole system</span>] (see bottom of page 517), he also tells us that [<span class="citation">the modal rate of defects found by unit testing are only 30 to 35 percent</span>] (page 470) and that [<span class="citation">the best way to find a maximum of defects at the earliest stage is a combination of different methods</span>].</p></td></tr></table></div></li><li><p>Statically typed languages typically have better runtime-performance than dynamically typed languages.</p><p>The reason is that dynamically typed languages have to evaluate and check types at runtime, while statically typed languages do this at compile-time.</p></li></ul></div><p>To conclude, we can say that static typing requires the programmer to think a bit more before writing a bit more code, but the final rewards are manyfold:</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_typing_see_also"></a>See also</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><a href="case_type_of_instruction.html" title="case type of instruction">the section called &#8220;<code class="code">case type of</code> instruction&#8221;</a></li><li><a href="type_inheritance.html" title="Chapter 12. Type inheritance">Chapter 12, <i>Type inheritance</i></a></li><li><a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Chapter 10, <i>Feature redefinition</i></a></li><li><a href="generic_types.html" title="Chapter 9. Generic types">Chapter 9, <i>Generic types</i></a></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="object_immutability.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><td width="20%" align="center"><a accesskey="u" href="advanced_concepts.html"><img src="images/up.png" alt="Go up one level" title="Go up one level"></a></td><td width="40%" align="right"> <a accesskey="n" href="generic_types.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 7. Object immutability </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Table of contents" title="Table of contents"></a></td><td width="40%" align="right" valign="top"> Chapter 9. Generic types</td></tr></table></div></body></html>
