<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 4. Contract Programming, also called Design by Contract (TM)</title><link rel="stylesheet" href="obix_doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><meta name="description" content="Contract Programming or Design by Contract is fully integrated in the Obix programming language because it increases software reliability."><meta name="keywords" content="design by contract, contract programming, programming by contract, code contract, contracted code, defensive programming, fail fast principle, software bug prevention, software reliability, reliable code, reliable software"><link rel="start" href="index.html" title="Obix programming language documentation"><link rel="up" href="advanced_concepts.html" title="Part II. Concepts for more reliable code"><link rel="prev" href="advanced_concepts.html" title="Part II. Concepts for more reliable code"><link rel="next" href="testing.html" title="Chapter 5. Testing"><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29648172-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Contract Programming, also called Design by Contract (TM)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="advanced_concepts.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><th width="60%" align="center">Part II. Concepts for more reliable code</th><td width="20%" align="right"> <a accesskey="n" href="testing.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="design_by_contract_contract_programming"></a>Chapter 4. Contract Programming, also called Design by Contract (TM)</h2></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p><span class="emphasis"><em>Contract Programming</em></span> or <span class="emphasis"><em>Design by Contract</em></span>  is fully integrated in the Obix programming language because it  <span class="emphasis"><em>increases software reliability</em></span>.</p></div></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The following synonyms are used in the programming world to denote the same concept:
			</p><div class="itemizedlist"><ul type="disc"><li><em class="firstterm">Design by Contract (TM)</em></li><li><em class="firstterm">Contract Programming</em></li><li><em class="firstterm">Programming by Contract</em></li><li><em class="firstterm">Code Contracts</em></li><li><em class="firstterm">Contracted Code</em></li></ul></div><p>
		</p></td></tr></table></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_picture"></a>... in a picture</h2></div></div></div><div class="informalfigure"><a name="design_by_contract_programming_guard"></a><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="200"><tr><td><img src="design_by_contract_programming_guard.png" width="200" alt="Design by contract programming safety guard"></td></tr></table><div class="caption"><p><span class="emphasis"><em>Contract Programming (Design by Contract)</em></span> works like many safety guards who constantly ensure that invalid data cannot enter or exit software components.</p></div></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="design_by_contract_nutshell"></a>... in a nutshell</h2></div></div></div><p>The basic idea of <em class="firstterm">Contract Programming</em> is to <span class="emphasis"><em>add data validation checks</em></span> in the source code. These checks ensure that invalid data exchanged between software components is rejected immediately and automatically. As soon as data doesn't pass a validation check at runtime a program error is raised.</p><p>As a result a good number of program errors are detected quickly and automatically.</p><p>You can also think of <span class="emphasis"><em>Contract Programming</em></span> as many little firewalls installed in your application and protecting software components from illegal or malicious attacks. To illustrate what can happen in case of an application without <span class="emphasis"><em>Contract Programming</em></span> just imagine what can happen in case of a web server without firewall protection.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="design_by_contract_example"></a>... in a simple example</h2></div></div></div><p>Type <code class="code">string</code> in Obix's standard library has command (function) <code class="code">extract_from_to</code>. This command extracts a substring, starting at position <code class="code">from</code> of the string and ending at position <code class="code">to</code>.</p><p>Without <span class="emphasis"><em>Contract Programming</em></span> the code for type string would be as follows:
        </p><pre class="programlisting">type string

   command extract_from_to
      in from type:positive32 end
      in to type:positive32 end
		
      out result type:string end
   end
	
   // other 'string' commands omitted

end type</pre><p>
    </p><p>It is obvious that calling <code class="code">extract_from_to</code> only makes sense if the following conditions are fulfilled:
		</p><div class="itemizedlist"><ul type="disc"><li>the value of <code class="code">from</code> is less than or equal to the length of the string</li><li>the value of <code class="code">to</code> is less than or equal to the length of the string</li><li>the value of <code class="code">from</code> is less than or equal to the value of <code class="code">to</code></li></ul></div><p>
	</p><p>Moreover we can state that the length of the <code class="code">result</code> string must be equal to <code class="code">to - from + 1</code></p><p>These conditions can be expressed with <span class="emphasis"><em>Contract Programming</em></span>. The above code rewritten with data validation checks becomes:
        </p><pre class="programlisting">type string

   command extract_from_to
      in from type:positive32 check: from &lt;= object_.item_count end
      in to type:positive32 check: to &lt;= object_.item_count end
      in_check check: from &lt;= to end
		
      out result type:string check: result.item_count =v to - from + 1 end
   end

end type</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">The check for input argument <code class="code">from</code> could be omitted because the other two input conditions (<code class="code">from &lt;= to</code> and <code class="code">to &lt;= object_.item_count</code> imply that <code class="code">from &lt;= object_.item_count</code> is also fulfilled.</td></tr></table></div><p>Adding <span class="emphasis"><em>Contract Programming</em></span> to your source code has <span class="emphasis"><em>many benefits</em></span>, as explained in the next section.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="design_by_contract_benefits"></a>Benefits of using <span class="emphasis"><em>Contract Programming</em></span> in your applications</h2></div></div></div><p><span class="emphasis"><em>Contract Programming</em></span>:

		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>leads to more reliable and more <a href="http://en.wikipedia.org/wiki/Maintainability" target="_top">maintainable</a> software.</strong></span></p><p><span class="emphasis"><em>Contract Programming</em></span> is a very effective application of the important <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Fail-fast" target="_top">Fail fast!</a></em></span> principle. It supports <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Defensive_programming" target="_top">defensive programming</a></em></span> and software bug prevention. As a result it leads to more reliable and more maintainable software.</p></li></ul></div><p>

		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>helps to detect many program errors quickly and automatically</strong></span></p><p>A typical application contains hundreds or thousands of <span class="emphasis"><em>Contract Programming</em></span> conditions scattered everywhere throughout the source code. These conditions are continuously verified at runtime, so that any violation immediately generates a runtime error. This helps debugging, especially when client and supplier code is written by different programmers. In many cases it also reduces the time needed to correct an error because the source of the error is immediately revealed.</p></li></ul></div><p>
		
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>documents the code in a reliable manner</strong></span></p><p><span class="emphasis"><em>Contract Programming</em></span> documents program interfaces in a reliable way. By just looking at a command's input checks, for example, you can quickly understand the conditions that must be fulfilled before you can call the command. This avoids misunderstandings between client and supplier code (possibly written by different programmers).</p><p>Without <span class="emphasis"><em>Contract Programming</em></span>, conditions could be expressed through a comment in the source code. But comments cannot be understood and used by the compiler to actually check the condition at runtime. Moreover comments can be in discordance with the source code and they can be outdated after changing the code without changing the comment.</p></li></ul></div><p>
		
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>makes implementation code simpler and more consistent</strong></span></p><p>Have a look at the above example code of type <code class="code">string</code>.</p><p>Without <span class="emphasis"><em>Contract Programming</em></span> conditions any factory that implements command <code class="code">extract_from_to</code> has to deal in some way with each case of invalid input data and decide what to do. If <code class="code">from</code> is greater than <code class="code">to</code>, for example, there are at least 3 ways to deal with this case. The factory could (1) throw an error or (2) return a <code class="code">void</code> value or (3) return an empty string. Different factories implementing type <code class="code">string</code> could apply different ways to handle invalid input data. It is easy to see that this can easily lead to unforeseeable and inconsistent behavior between objects of the same type. The programmer would have to look at each factory's implementation code in order to understand what happens in a given case of invalid data. <span class="emphasis"><em>Contract Programming</em></span> eliminates these problems. Every factory can reliably assume that input is in a valid state. This makes the implementation code to write much simpler. And there is no inconsistent behavior between different factories implementing the same type.</p><p>Another benefit is that the factories' implementation code is implicitly checked (to a certain degree) for erroneous results, because the output condition <code class="code">result.item_count =v to - from + 1</code> is implicitly checked for any factory and for any case of input values.</p></li></ul></div><p>
		
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>ensures that conditions are automatically inherited in child types, but allows for redefining them if necessary</strong></span></p><p>A fundamental rule of object oriented programming is that a child type must always be compatible to its parent type. Therefore <span class="emphasis"><em>Contract Programming</em></span> conditions are implicitly inherited in child types. You don't have to restate the checks in child types - the compiler takes care of this.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Sometimes, it is necessary to weaken input conditions or to strengthen output conditions in child types. This is called <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29" target="_top">Contravariance and Covariance</a> in computer science. Obix supports these techniques in a type-safe way, as explained below.</td></tr></table></div></li></ul></div><p>
		
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_drawbacks"></a>Drawbacks of <span class="emphasis"><em>Contract Programming</em></span></h2></div></div></div><p>There are no general drawbacks of <span class="emphasis"><em>Contract Programming</em></span>. However the following two points must be considered:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>The programmer has to "write a little bit more"</strong></span></p><p>The compiler cannot deduce <span class="emphasis"><em>Contract Programming</em></span> conditions to be inserted in the code. They have to be written manually. Some programmers might therefore refrain from using this powerful technique because "writing more makes me less productive". This is of course a silly argument because not using <span class="emphasis"><em>Contract Programming</em></span> simply means more bugs in the software and more time (and frustration and money) spent to find and repair the bugs. The serious programmer who wants to write high quality code will quickly be convinced of all the benefits and use <span class="emphasis"><em>Contract Programming</em></span> consistently.</p></li><li><p><span class="bold"><strong>Contract Programming might create performance problems in specific cases</strong></span></p><p>Constantly checking all conditions at runtime takes time. Therefore an application using <span class="emphasis"><em>Contract Programming</em></span> will run slower. Two questions arise:</p><div class="itemizedlist"><ul type="circle"><li>How much slower?</li><li>Does this performance loss actually penalize my application?</li></ul></div><p>There is no general answer to these questions. It depends. Practice shows that in most cases performance is not a concern. It is typically assumed that an application with <span class="emphasis"><em>Contract Programming</em></span> enabled runs about 30% slower.</p><p>If you encounter performance problems then you can proceed as follows:</p><div class="itemizedlist"><ul type="circle"><li>Measure performance</li><li>Determine if there are performance problems due to <span class="emphasis"><em>Contract Programming</em></span> conditions taking a lot of time to be evaluated. If such problems exist then consider rewriting the conditions to make them faster or (as a last resort and after extensive testing) disable them in production mode.</li></ul></div></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_rules"></a>Implementation of <span class="emphasis"><em>Contract Programming (Design by Contract)</em></span> in Obix</h2></div></div></div><p>As said already, <span class="emphasis"><em>Contract Programming</em></span> consists of adding conditions at specific places in the source code in order to protect software components against invalid data. A <em class="firstterm">condition</em> is a <code class="code">yes_no (boolean)</code> expression which must evaluate to <code class="code">yes (true)</code> in the case of valid data. A condition would be used, for example, to specify that the length of a <code class="code">name</code> cannot exceed 70 characters. During execution of the program conditions are constantly checked and a runtime error occurs immediately whenever a condition is violated. Thus, in our example, a runtime error would occur immediately if a <code class="code">name</code> is set to a value consisting of more than 70 characters.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is interesting to note that while <span class="emphasis"><em><a href="static_typing.html" title="Chapter 8. Static typing">static typing</a></em></span> ensures that only an object of a defined type (or any compatible type) can be assigned to an object reference, <span class="emphasis"><em>Contract Programming</em></span> goes a step further by limiting the set of allowed values that can be assigned. For example, <span class="emphasis"><em>static typing</em></span> would ensure that only an object of type <code class="code">string</code> can be assigned to attribute <code class="code">name</code> (which is of type <code class="code">string</code>), whereas <span class="emphasis"><em>Contract Programming</em></span> ensures that the length of the string is limited to 70 characters.</p><p>Another point to note is that <span class="emphasis"><em>static typing</em></span> violations are detected at <span class="emphasis"><em>compile-time</em></span>, whereas <span class="emphasis"><em>Contract programming</em></span> violations are detected at <span class="emphasis"><em>run-time</em></span>.</p></td></tr></table></div><p>The rules for <span class="emphasis"><em>Contract programming</em></span> in Obix are as follows:</p><div class="orderedlist"><ol type="1"><li><p>There are four kinds of <span class="emphasis"><em>Contract Programming</em></span> conditions:</p><div class="orderedlist"><ol type="a"><li><p><span class="bold"><strong>Attribute conditions</strong></span></p><p><span class="emphasis"><em>Attribute conditions</em></span> are used to protect attributes of objects and services against invalid data. They ensure that the state (i.e. the set of all attribute values) of an object or service is valid.</p><p><span class="emphasis"><em>Attribute conditions</em></span> can be defined:</p><div class="itemizedlist"><ul type="disc"><li><p>for a single attribute</p><p>example: attribute <code class="code">name</code> of type <code class="code">customer</code> cannot exceed 70 characters</p></li><li><p>for multiple attributes of the same type or service</p><p>example: Suppose type <code class="code">address</code> has attributes <code class="code">postal_code</code>, <code class="code">city</code>, and <code class="code">country</code>. <span class="emphasis"><em>Contract Programming</em></span> could then be used to ensure that the <code class="code">city</code> actually exists in the <code class="code">country</code>, and that the <code class="code">postal_code</code> exists for that <code class="code">city</code>.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">In computer science the term <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Class_invariant" target="_top">class invariant</a></em></span> is used to denote the concept of <span class="emphasis"><em>attribute conditions</em></span> used in Obix.</td></tr></table></div></li><li><p><span class="bold"><strong>Command input conditions</strong></span></p><p><span class="emphasis"><em>Command input conditions</em></span> are conditions that must be fulfilled <span class="emphasis"><em>before</em></span> a command is executed. They protect a command against invalid input.</p><p><span class="emphasis"><em>Command input conditions</em></span> can be defined:</p><div class="itemizedlist"><ul type="disc"><li><p>for a single input argument</p><p>an example was given above: the value of input argument <code class="code">from</code> of command <code class="code">extract_from_to</code> must be less than or equal to the length of the string</p></li><li><p>for multiple input arguments of the command</p><p>an example was given above: the value of input argument <code class="code">from</code> of command <code class="code">extract_from_to</code> must be less than or equal to the value of <code class="code">to</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">In computer science the term <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Precondition" target="_top">precondition</a></em></span> is used to denote the concept of <span class="emphasis"><em>command input conditions</em></span> used in Obix.</td></tr></table></div></li><li><p><span class="bold"><strong>Command output conditions</strong></span></p><p><span class="emphasis"><em>Command output conditions</em></span> are conditions that must be fulfilled <span class="emphasis"><em>after</em></span> a command is executed. They ensure that invalid output from a command is rejected.</p><p><span class="emphasis"><em>Command output conditions</em></span> can be defined:</p><div class="itemizedlist"><ul type="disc"><li><p>for a single output argument</p><p>an example was given above: the length of output argument <code class="code">result</code> must be equal to <code class="code">to - from + 1</code></p></li><li><p>for multiple output arguments of the command</p><p>example: a network connection must be available after executing a command that establishes this connection, or else an error must be returned.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">In computer science the term <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Postcondition" target="_top">postcondition</a></em></span> is used to denote the concept of <span class="emphasis"><em>command output conditions</em></span> used in Obix.</td></tr></table></div></li><li><p><span class="bold"><strong>Script conditions</strong></span></p><p><span class="emphasis"><em>Script conditions</em></span> are conditions that can be inserted anywhere in a script. They are used to ensure a valid state of one or more objects at a certain point in the script.</p><p>examples: ensure a <a href="http://en.wikipedia.org/wiki/Loop_invariant" target="_top">loop invariant</a>; ensure the sum of two integer variables to be less than 100; etc.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">In computer science the term <span class="emphasis"><em><a href="http://en.wikipedia.org/wiki/Assert" target="_top">Assertion</a></em></span> is used to denote the concept of <span class="emphasis"><em>script conditions</em></span> used in Obix.</td></tr></table></div></li></ol></div></li><li><p><span class="emphasis"><em>There are two ways to define <span class="emphasis"><em>Contract Programming</em></span> conditions:</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>Simple conditions are defined through an expression of type <code class="code">yes_no</code>. If the expression evaluates to <code class="code">yes</code>, the condition is fulfilled. If it evaluates to <code class="code">no</code> it is not fulfilled.</p></li><li><p>More complex and multiple conditions are defined through a check <span class="emphasis"><em>script</em></span> that returns <code class="code">void</code> if all conditions are fulfilled. As soon as a condition is unfulfilled, the script returns an error object describing the problem. A condition in the script is specified with the <code class="code">check</code> instruction (see <a href="error_handling_instructions.html#check_instruction" title="check instruction">the section called &#8220;<code class="code">check</code> instruction&#8221;</a>). The <code class="code">check</code> instruction evaluates an expression of type <code class="code">yes_no</code>. If the expression evaluates to <code class="code">yes</code>, the condition is fulfilled. If it evaluates to <code class="code">no</code> the condition is not fulfilled and the script immediately returns an error object.</p></li></ul></div><p>Please refer to the links in the following table for details about how to code the different kinds of conditions:</p><div class="table"><a name="contract_programming_links"></a><p class="title"><b>Table 4.1. Links for how to code <span class="emphasis"><em>Contract Programming</em></span></b></p><div class="table-contents"><table summary="Links for how to code Contract Programming" cellspacing="0" cellpadding="5" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Kind of condition</th><th>Sub-kind</th><th>How to code</th><th>Definition of check script</th></tr></thead><tbody><tr><td rowspan="2" valign="middle">Attribute conditions</td><td>check a single attribute</td><td><a href="RSE_features.html#attribute_check_property" title="Attribute property check">the section called &#8220;Attribute property <code class="code">check</code>&#8221;</a></td><td><a href="attribute_check_script.html" title="Attribute check script">the section called &#8220;Attribute <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check multiple attributes (i.e. the state of an object or service)</td><td><a href="RSE_features.html#attribute_list_check_property" title="Property attribute_check">the section called &#8220;Property <code class="code">attribute_check</code>&#8221;</a></td><td><a href="check_scripts.html#attribute_list_check_script" title="attribute_check script">the section called &#8220;<code class="code">attribute_check</code> script&#8221;</a></td></tr><tr><td rowspan="2" valign="middle">Command input conditions</td><td>check a single input argument</td><td><a href="command.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></td><td><a href="input_argument_check_script.html" title="Input argument check script">the section called &#8220;Input argument <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check multiple input arguments</td><td><a href="command.html#logger_service_in_check" title="Example 18.7. in_check (using an expression)">Example 18.7, &#8220;<code class="code">in_check</code> (using an expression)&#8221;</a></td><td><a href="command_in_check_script.html" title="Command in_check script">the section called &#8220;Command <code class="code">in_check</code> script&#8221;</a></td></tr><tr><td rowspan="2" valign="middle">Command output conditions</td><td>check a single output argument</td><td><a href="command.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></td><td><a href="output_argument_check_script.html" title="Output argument check script">the section called &#8220;Output argument <code class="code">check</code> script&#8221;</a></td></tr><tr><td>check multiple output arguments</td><td><a href="command.html#logger_service_output_example" title="Example 18.8. Multiple output arguments">Example 18.8, &#8220;Multiple output arguments&#8221;</a></td><td><a href="command_out_check_script.html" title="Command out_check script">the section called &#8220;Command <code class="code">out_check</code> script&#8221;</a></td></tr><tr><td>Script conditions</td><td> </td><td><a href="check_script_instruction.html" title="check script instruction">the section called &#8220;<code class="code">check script</code> instruction&#8221;</a></td><td>N/A</td></tr></tbody></table></div></div><br class="table-break"></li><li><p><span class="emphasis"><em>Contract Programming conditions defined in a type are implicitly inherited in every child type</em></span></p><p>This rule is a logical consequence of the <a href="type_inheritance.html#type_compatibility_rule">type compatibility rule</a>. Because a child type is always compatible to all its parent types, all <span class="emphasis"><em>Contract Programming</em></span> conditions defined in a type are also enforced in all child types.</p><p>For example, if a type's command returns an integer value that is guaranteed to be greater than 10, a child type must also ensure this condition. Returning the value 7, for example, would be rejected.</p></li><li><p><span class="emphasis"><em>Contract Programming conditions defined in a type can be weakened or strengthened in a child type, as long as type compatibility is preserved.</em></span></p><p>Please refer to <a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Chapter 10, <i>Feature redefinition</i></a> for more information.</p></li><li><p><span class="emphasis"><em>Contract Programming conditions defined in a type are automatically enforced in every factory that implements this type.</em></span></p><p>There is no need to explicitly (re)check conditions in factories. For example, if a type specifies that a command's input argument of type <code class="code">string</code> must contain at least 10 characters, then any factory implementing this type (or a child-type) can rely on this condition and doesn't need to add code such as <code class="code">if input_value.item_count &lt; 10 then ...</code>.</p></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_tips"></a>Tips</h2></div></div></div><p>Here are two tips to consider when using <span class="emphasis"><em>Contract Programming</em></span>.</p><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>To ensure that an object reference cannot be <code class="code">void</code> at runtime, property <code class="code">voidable</code> should be used, rather than Contract Programming.</em></span></p><p>Although <span class="emphasis"><em>Contract Programming</em></span> could be used to check for <code class="code">void</code>, using property <code class="code">voidable</code> is easier to use, and allows the compiler to make some optimizations. However, if the check for <code class="code">void</code> depends on circumstances at runtime, then  <span class="emphasis"><em>Contract Programming</em></span> must be used (e.g. an attribute's voidability depends on a parameter stored in an XML configuration file)</p><p>Please refer to the following links for more information:</p><div class="itemizedlist"><ul type="disc"><li><a href="RSE_features.html#attribute_voidable_property" title="Attribute property voidable">the section called &#8220;Attribute property <code class="code">voidable</code>&#8221;</a> (attribute)</li><li><a href="command.html#argument_voidable_property" title="Argument property voidable">the section called &#8220;Argument property <code class="code">voidable</code>&#8221;</a> (input/output argument)</li><li><a href="void_values.html" title="Chapter 6. Void values">Chapter 6, <i>Void values</i></a></li></ul></div><p></p></li><li><p><span class="emphasis"><em>If the same condition is defined for more than one attribute, input argument or output argument then consider defining a new type that contains this condition and use this type for each object reference.</em></span></p><p>Suppose types <code class="code">meeting</code> and <code class="code">asset</code> both have attribute <code class="code">remark</code> which is a <code class="code">string</code> limited to 1024 characters. The types could be defined as follows:</p><pre class="programlisting">type meeting 

   // some attributes not shown here

   attribute remark type:string check: i_remark.item_count &lt;= 1024 end

end</pre><pre class="programlisting">type asset 

   // some attributes not shown here

   attribute remark type:string check: i_remark.item_count &lt;= 1024 end

end</pre><p>A much better solution is to define a new type <code class="code">remark</code> as:</p><pre class="programlisting">type remark

   inherit string
      attribute value and_check: i_value.item_count &lt;= 1024 end
   end

end</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This code uses <span class="emphasis"><em>type inheritance</em></span> and <span class="emphasis"><em>feature redefinition</em></span>. Please refer to <a href="type_inheritance.html" title="Chapter 12. Type inheritance">Chapter 12, <i>Type inheritance</i></a> and <a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Chapter 10, <i>Feature redefinition</i></a> for more information about these techniques.</p></td></tr></table></div><p>Now types <code class="code">meeting</code> and <code class="code">asset</code> can both use type <code class="code">remark</code> like this:</p><pre class="programlisting">type meeting_2

   // some attributes not shown here

   attribute remark type:remark end

end</pre><pre class="programlisting">type asset_2

   // some attributes not shown here

   attribute remark type:remark end

end</pre><p>Besides the obvious advantage that the code gets easier to write, the design has been improved for the following reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>Code duplication, one of the biggest enemies of software maintainability, has been eliminated.</p><p>If the limit of <code class="code">remark</code> is later changed to 2048 there is only one place to change in the code (i.e. type <code class="code">remark</code>). This saves time and eliminates the risk of forgetting to make the same change in other types that have a <code class="code">remark</code> attribute.</p></li><li><p>The same type <code class="code">remark</code> can now easily be used in other types with a <code class="code">remark</code> attribute.</p></li><li><p>Type safety is increased, because a <code class="code">remark</code> is now semantically different from a standard <code class="code">string</code>.</p><p>For example, an error like assigning the name of an elephant (defined as <code class="code">string</code>) to the <code class="code">remark</code> attribute of a <code class="code">meeting</code> object would be detected by the compiler.</p></li></ul></div></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_examples"></a>Examples</h2></div></div></div><p>Examples of <span class="emphasis"><em>Contract Programming</em></span> can be found in the links listed in the following section.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contract_programming_see_also"></a>See also</h2></div></div></div><p>attributes:</p><div class="itemizedlist"><ul type="disc"><li><a href="RSE_features.html#attribute_check_property" title="Attribute property check">the section called &#8220;Attribute property <code class="code">check</code>&#8221;</a></li><li><a href="RSE_features.html#attribute_list_check_property" title="Property attribute_check">the section called &#8220;Property <code class="code">attribute_check</code>&#8221;</a></li><li><a href="attribute_check_script.html" title="Attribute check script">the section called &#8220;Attribute <code class="code">check</code> script&#8221;</a></li><li><a href="check_scripts.html#attribute_list_check_script" title="attribute_check script">the section called &#8220;<code class="code">attribute_check</code> script&#8221;</a></li></ul></div><p>input/output arguments:</p><div class="itemizedlist"><ul type="disc"><li><a href="command.html#argument_check_property" title="Argument property check">the section called &#8220;Argument property <code class="code">check</code>&#8221;</a></li><li><a href="input_argument_check_script.html" title="Input argument check script">the section called &#8220;Input argument <code class="code">check</code> script&#8221;</a></li><li><a href="command_in_check_script.html" title="Command in_check script">the section called &#8220;Command <code class="code">in_check</code> script&#8221;</a></li><li><a href="output_argument_check_script.html" title="Output argument check script">the section called &#8220;Output argument <code class="code">check</code> script&#8221;</a></li><li><a href="command_out_check_script.html" title="Command out_check script">the section called &#8220;Command <code class="code">out_check</code> script&#8221;</a></li></ul></div><p>related topics:</p><div class="itemizedlist"><ul type="disc"><li><a href="void_values.html" title="Chapter 6. Void values">Chapter 6, <i>Void values</i></a></li><li><a href="feature_redefinition.html" title="Chapter 10. Feature redefinition">Chapter 10, <i>Feature redefinition</i></a></li><li><a href="error_handling.html" title="Chapter 11. Runtime error handling">Chapter 11, <i>Runtime error handling</i></a></li><li><a href="static_typing.html" title="Chapter 8. Static typing">Chapter 8, <i>Static typing</i></a></li><li><a href="type_inheritance.html" title="Chapter 12. Type inheritance">Chapter 12, <i>Type inheritance</i></a></li></ul></div><p>instructions:</p><div class="itemizedlist"><ul type="disc"><li><a href="error_handling_instructions.html#check_instruction" title="check instruction">the section called &#8220;<code class="code">check</code> instruction&#8221;</a></li><li><a href="check_script_instruction.html" title="check script instruction">the section called &#8220;<code class="code">check script</code> instruction&#8221;</a></li></ul></div><p>Wikipedia links:</p><div class="itemizedlist"><ul type="disc"><li><a href="http://en.wikipedia.org/wiki/Design_by_contract" target="_top">Design by Contract</a></li><li><a href="http://en.wikipedia.org/wiki/Defensive_programming" target="_top">Defensive programming</a></li><li><a href="http://en.wikipedia.org/wiki/Class_invariant" target="_top">Class invariant</a></li><li><a href="http://en.wikipedia.org/wiki/Precondition" target="_top">Precondition</a></li><li><a href="http://en.wikipedia.org/wiki/Postcondition" target="_top">Postcondition</a></li><li><a href="http://en.wikipedia.org/wiki/Assert" target="_top">Assertion</a></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced_concepts.html"><img src="images/prev.png" alt="Previous chapter" title="Previous chapter"></a> </td><td width="20%" align="center"><a accesskey="u" href="advanced_concepts.html"><img src="images/up.png" alt="Go up one level" title="Go up one level"></a></td><td width="40%" align="right"> <a accesskey="n" href="testing.html"><img src="images/next.png" alt="Next chapter" title="Next chapter"></a></td></tr><tr><td width="40%" align="left" valign="top">Part II. Concepts for more reliable code </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Table of contents" title="Table of contents"></a></td><td width="40%" align="right" valign="top"> Chapter 5. Testing</td></tr></table></div></body></html>
